package descriptor

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/v2/insolar"
)

// CacheMock implements Cache
type CacheMock struct {
	t minimock.Tester

	funcByObjectDescriptor          func(ctx context.Context, obj ObjectDescriptor) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)
	inspectFuncByObjectDescriptor   func(ctx context.Context, obj ObjectDescriptor)
	afterByObjectDescriptorCounter  uint64
	beforeByObjectDescriptorCounter uint64
	ByObjectDescriptorMock          mCacheMockByObjectDescriptor

	funcByPrototypeRef          func(ctx context.Context, protoRef insolar.Reference) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)
	inspectFuncByPrototypeRef   func(ctx context.Context, protoRef insolar.Reference)
	afterByPrototypeRefCounter  uint64
	beforeByPrototypeRefCounter uint64
	ByPrototypeRefMock          mCacheMockByPrototypeRef

	funcGetCode          func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)
	inspectFuncGetCode   func(ctx context.Context, ref insolar.Reference)
	afterGetCodeCounter  uint64
	beforeGetCodeCounter uint64
	GetCodeMock          mCacheMockGetCode

	funcGetPrototype          func(ctx context.Context, ref insolar.Reference) (p1 PrototypeDescriptor, err error)
	inspectFuncGetPrototype   func(ctx context.Context, ref insolar.Reference)
	afterGetPrototypeCounter  uint64
	beforeGetPrototypeCounter uint64
	GetPrototypeMock          mCacheMockGetPrototype
}

// NewCacheMock returns a mock for Cache
func NewCacheMock(t minimock.Tester) *CacheMock {
	m := &CacheMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ByObjectDescriptorMock = mCacheMockByObjectDescriptor{mock: m}
	m.ByObjectDescriptorMock.callArgs = []*CacheMockByObjectDescriptorParams{}

	m.ByPrototypeRefMock = mCacheMockByPrototypeRef{mock: m}
	m.ByPrototypeRefMock.callArgs = []*CacheMockByPrototypeRefParams{}

	m.GetCodeMock = mCacheMockGetCode{mock: m}
	m.GetCodeMock.callArgs = []*CacheMockGetCodeParams{}

	m.GetPrototypeMock = mCacheMockGetPrototype{mock: m}
	m.GetPrototypeMock.callArgs = []*CacheMockGetPrototypeParams{}

	return m
}

type mCacheMockByObjectDescriptor struct {
	mock               *CacheMock
	defaultExpectation *CacheMockByObjectDescriptorExpectation
	expectations       []*CacheMockByObjectDescriptorExpectation

	callArgs []*CacheMockByObjectDescriptorParams
	mutex    sync.RWMutex
}

// CacheMockByObjectDescriptorExpectation specifies expectation struct of the Cache.ByObjectDescriptor
type CacheMockByObjectDescriptorExpectation struct {
	mock    *CacheMock
	params  *CacheMockByObjectDescriptorParams
	results *CacheMockByObjectDescriptorResults
	Counter uint64
}

// CacheMockByObjectDescriptorParams contains parameters of the Cache.ByObjectDescriptor
type CacheMockByObjectDescriptorParams struct {
	ctx context.Context
	obj ObjectDescriptor
}

// CacheMockByObjectDescriptorResults contains results of the Cache.ByObjectDescriptor
type CacheMockByObjectDescriptorResults struct {
	p1  PrototypeDescriptor
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for Cache.ByObjectDescriptor
func (mmByObjectDescriptor *mCacheMockByObjectDescriptor) Expect(ctx context.Context, obj ObjectDescriptor) *mCacheMockByObjectDescriptor {
	if mmByObjectDescriptor.mock.funcByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("CacheMock.ByObjectDescriptor mock is already set by Set")
	}

	if mmByObjectDescriptor.defaultExpectation == nil {
		mmByObjectDescriptor.defaultExpectation = &CacheMockByObjectDescriptorExpectation{}
	}

	mmByObjectDescriptor.defaultExpectation.params = &CacheMockByObjectDescriptorParams{ctx, obj}
	for _, e := range mmByObjectDescriptor.expectations {
		if minimock.Equal(e.params, mmByObjectDescriptor.defaultExpectation.params) {
			mmByObjectDescriptor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmByObjectDescriptor.defaultExpectation.params)
		}
	}

	return mmByObjectDescriptor
}

// Inspect accepts an inspector function that has same arguments as the Cache.ByObjectDescriptor
func (mmByObjectDescriptor *mCacheMockByObjectDescriptor) Inspect(f func(ctx context.Context, obj ObjectDescriptor)) *mCacheMockByObjectDescriptor {
	if mmByObjectDescriptor.mock.inspectFuncByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("Inspect function is already set for CacheMock.ByObjectDescriptor")
	}

	mmByObjectDescriptor.mock.inspectFuncByObjectDescriptor = f

	return mmByObjectDescriptor
}

// Return sets up results that will be returned by Cache.ByObjectDescriptor
func (mmByObjectDescriptor *mCacheMockByObjectDescriptor) Return(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *CacheMock {
	if mmByObjectDescriptor.mock.funcByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("CacheMock.ByObjectDescriptor mock is already set by Set")
	}

	if mmByObjectDescriptor.defaultExpectation == nil {
		mmByObjectDescriptor.defaultExpectation = &CacheMockByObjectDescriptorExpectation{mock: mmByObjectDescriptor.mock}
	}
	mmByObjectDescriptor.defaultExpectation.results = &CacheMockByObjectDescriptorResults{p1, c2, err}
	return mmByObjectDescriptor.mock
}

//Set uses given function f to mock the Cache.ByObjectDescriptor method
func (mmByObjectDescriptor *mCacheMockByObjectDescriptor) Set(f func(ctx context.Context, obj ObjectDescriptor) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)) *CacheMock {
	if mmByObjectDescriptor.defaultExpectation != nil {
		mmByObjectDescriptor.mock.t.Fatalf("Default expectation is already set for the Cache.ByObjectDescriptor method")
	}

	if len(mmByObjectDescriptor.expectations) > 0 {
		mmByObjectDescriptor.mock.t.Fatalf("Some expectations are already set for the Cache.ByObjectDescriptor method")
	}

	mmByObjectDescriptor.mock.funcByObjectDescriptor = f
	return mmByObjectDescriptor.mock
}

// When sets expectation for the Cache.ByObjectDescriptor which will trigger the result defined by the following
// Then helper
func (mmByObjectDescriptor *mCacheMockByObjectDescriptor) When(ctx context.Context, obj ObjectDescriptor) *CacheMockByObjectDescriptorExpectation {
	if mmByObjectDescriptor.mock.funcByObjectDescriptor != nil {
		mmByObjectDescriptor.mock.t.Fatalf("CacheMock.ByObjectDescriptor mock is already set by Set")
	}

	expectation := &CacheMockByObjectDescriptorExpectation{
		mock:   mmByObjectDescriptor.mock,
		params: &CacheMockByObjectDescriptorParams{ctx, obj},
	}
	mmByObjectDescriptor.expectations = append(mmByObjectDescriptor.expectations, expectation)
	return expectation
}

// Then sets up Cache.ByObjectDescriptor return parameters for the expectation previously defined by the When method
func (e *CacheMockByObjectDescriptorExpectation) Then(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *CacheMock {
	e.results = &CacheMockByObjectDescriptorResults{p1, c2, err}
	return e.mock
}

// ByObjectDescriptor implements Cache
func (mmByObjectDescriptor *CacheMock) ByObjectDescriptor(ctx context.Context, obj ObjectDescriptor) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmByObjectDescriptor.beforeByObjectDescriptorCounter, 1)
	defer mm_atomic.AddUint64(&mmByObjectDescriptor.afterByObjectDescriptorCounter, 1)

	if mmByObjectDescriptor.inspectFuncByObjectDescriptor != nil {
		mmByObjectDescriptor.inspectFuncByObjectDescriptor(ctx, obj)
	}

	mm_params := &CacheMockByObjectDescriptorParams{ctx, obj}

	// Record call args
	mmByObjectDescriptor.ByObjectDescriptorMock.mutex.Lock()
	mmByObjectDescriptor.ByObjectDescriptorMock.callArgs = append(mmByObjectDescriptor.ByObjectDescriptorMock.callArgs, mm_params)
	mmByObjectDescriptor.ByObjectDescriptorMock.mutex.Unlock()

	for _, e := range mmByObjectDescriptor.ByObjectDescriptorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.c2, e.results.err
		}
	}

	if mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation.Counter, 1)
		mm_want := mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation.params
		mm_got := CacheMockByObjectDescriptorParams{ctx, obj}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmByObjectDescriptor.t.Errorf("CacheMock.ByObjectDescriptor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmByObjectDescriptor.ByObjectDescriptorMock.defaultExpectation.results
		if mm_results == nil {
			mmByObjectDescriptor.t.Fatal("No results are set for the CacheMock.ByObjectDescriptor")
		}
		return (*mm_results).p1, (*mm_results).c2, (*mm_results).err
	}
	if mmByObjectDescriptor.funcByObjectDescriptor != nil {
		return mmByObjectDescriptor.funcByObjectDescriptor(ctx, obj)
	}
	mmByObjectDescriptor.t.Fatalf("Unexpected call to CacheMock.ByObjectDescriptor. %v %v", ctx, obj)
	return
}

// ByObjectDescriptorAfterCounter returns a count of finished CacheMock.ByObjectDescriptor invocations
func (mmByObjectDescriptor *CacheMock) ByObjectDescriptorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByObjectDescriptor.afterByObjectDescriptorCounter)
}

// ByObjectDescriptorBeforeCounter returns a count of CacheMock.ByObjectDescriptor invocations
func (mmByObjectDescriptor *CacheMock) ByObjectDescriptorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByObjectDescriptor.beforeByObjectDescriptorCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.ByObjectDescriptor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmByObjectDescriptor *mCacheMockByObjectDescriptor) Calls() []*CacheMockByObjectDescriptorParams {
	mmByObjectDescriptor.mutex.RLock()

	argCopy := make([]*CacheMockByObjectDescriptorParams, len(mmByObjectDescriptor.callArgs))
	copy(argCopy, mmByObjectDescriptor.callArgs)

	mmByObjectDescriptor.mutex.RUnlock()

	return argCopy
}

// MinimockByObjectDescriptorDone returns true if the count of the ByObjectDescriptor invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockByObjectDescriptorDone() bool {
	for _, e := range m.ByObjectDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByObjectDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByObjectDescriptor != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		return false
	}
	return true
}

// MinimockByObjectDescriptorInspect logs each unmet expectation
func (m *CacheMock) MinimockByObjectDescriptorInspect() {
	for _, e := range m.ByObjectDescriptorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.ByObjectDescriptor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByObjectDescriptorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		if m.ByObjectDescriptorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.ByObjectDescriptor")
		} else {
			m.t.Errorf("Expected call to CacheMock.ByObjectDescriptor with params: %#v", *m.ByObjectDescriptorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByObjectDescriptor != nil && mm_atomic.LoadUint64(&m.afterByObjectDescriptorCounter) < 1 {
		m.t.Error("Expected call to CacheMock.ByObjectDescriptor")
	}
}

type mCacheMockByPrototypeRef struct {
	mock               *CacheMock
	defaultExpectation *CacheMockByPrototypeRefExpectation
	expectations       []*CacheMockByPrototypeRefExpectation

	callArgs []*CacheMockByPrototypeRefParams
	mutex    sync.RWMutex
}

// CacheMockByPrototypeRefExpectation specifies expectation struct of the Cache.ByPrototypeRef
type CacheMockByPrototypeRefExpectation struct {
	mock    *CacheMock
	params  *CacheMockByPrototypeRefParams
	results *CacheMockByPrototypeRefResults
	Counter uint64
}

// CacheMockByPrototypeRefParams contains parameters of the Cache.ByPrototypeRef
type CacheMockByPrototypeRefParams struct {
	ctx      context.Context
	protoRef insolar.Reference
}

// CacheMockByPrototypeRefResults contains results of the Cache.ByPrototypeRef
type CacheMockByPrototypeRefResults struct {
	p1  PrototypeDescriptor
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for Cache.ByPrototypeRef
func (mmByPrototypeRef *mCacheMockByPrototypeRef) Expect(ctx context.Context, protoRef insolar.Reference) *mCacheMockByPrototypeRef {
	if mmByPrototypeRef.mock.funcByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("CacheMock.ByPrototypeRef mock is already set by Set")
	}

	if mmByPrototypeRef.defaultExpectation == nil {
		mmByPrototypeRef.defaultExpectation = &CacheMockByPrototypeRefExpectation{}
	}

	mmByPrototypeRef.defaultExpectation.params = &CacheMockByPrototypeRefParams{ctx, protoRef}
	for _, e := range mmByPrototypeRef.expectations {
		if minimock.Equal(e.params, mmByPrototypeRef.defaultExpectation.params) {
			mmByPrototypeRef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmByPrototypeRef.defaultExpectation.params)
		}
	}

	return mmByPrototypeRef
}

// Inspect accepts an inspector function that has same arguments as the Cache.ByPrototypeRef
func (mmByPrototypeRef *mCacheMockByPrototypeRef) Inspect(f func(ctx context.Context, protoRef insolar.Reference)) *mCacheMockByPrototypeRef {
	if mmByPrototypeRef.mock.inspectFuncByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("Inspect function is already set for CacheMock.ByPrototypeRef")
	}

	mmByPrototypeRef.mock.inspectFuncByPrototypeRef = f

	return mmByPrototypeRef
}

// Return sets up results that will be returned by Cache.ByPrototypeRef
func (mmByPrototypeRef *mCacheMockByPrototypeRef) Return(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *CacheMock {
	if mmByPrototypeRef.mock.funcByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("CacheMock.ByPrototypeRef mock is already set by Set")
	}

	if mmByPrototypeRef.defaultExpectation == nil {
		mmByPrototypeRef.defaultExpectation = &CacheMockByPrototypeRefExpectation{mock: mmByPrototypeRef.mock}
	}
	mmByPrototypeRef.defaultExpectation.results = &CacheMockByPrototypeRefResults{p1, c2, err}
	return mmByPrototypeRef.mock
}

//Set uses given function f to mock the Cache.ByPrototypeRef method
func (mmByPrototypeRef *mCacheMockByPrototypeRef) Set(f func(ctx context.Context, protoRef insolar.Reference) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error)) *CacheMock {
	if mmByPrototypeRef.defaultExpectation != nil {
		mmByPrototypeRef.mock.t.Fatalf("Default expectation is already set for the Cache.ByPrototypeRef method")
	}

	if len(mmByPrototypeRef.expectations) > 0 {
		mmByPrototypeRef.mock.t.Fatalf("Some expectations are already set for the Cache.ByPrototypeRef method")
	}

	mmByPrototypeRef.mock.funcByPrototypeRef = f
	return mmByPrototypeRef.mock
}

// When sets expectation for the Cache.ByPrototypeRef which will trigger the result defined by the following
// Then helper
func (mmByPrototypeRef *mCacheMockByPrototypeRef) When(ctx context.Context, protoRef insolar.Reference) *CacheMockByPrototypeRefExpectation {
	if mmByPrototypeRef.mock.funcByPrototypeRef != nil {
		mmByPrototypeRef.mock.t.Fatalf("CacheMock.ByPrototypeRef mock is already set by Set")
	}

	expectation := &CacheMockByPrototypeRefExpectation{
		mock:   mmByPrototypeRef.mock,
		params: &CacheMockByPrototypeRefParams{ctx, protoRef},
	}
	mmByPrototypeRef.expectations = append(mmByPrototypeRef.expectations, expectation)
	return expectation
}

// Then sets up Cache.ByPrototypeRef return parameters for the expectation previously defined by the When method
func (e *CacheMockByPrototypeRefExpectation) Then(p1 PrototypeDescriptor, c2 CodeDescriptor, err error) *CacheMock {
	e.results = &CacheMockByPrototypeRefResults{p1, c2, err}
	return e.mock
}

// ByPrototypeRef implements Cache
func (mmByPrototypeRef *CacheMock) ByPrototypeRef(ctx context.Context, protoRef insolar.Reference) (p1 PrototypeDescriptor, c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmByPrototypeRef.beforeByPrototypeRefCounter, 1)
	defer mm_atomic.AddUint64(&mmByPrototypeRef.afterByPrototypeRefCounter, 1)

	if mmByPrototypeRef.inspectFuncByPrototypeRef != nil {
		mmByPrototypeRef.inspectFuncByPrototypeRef(ctx, protoRef)
	}

	mm_params := &CacheMockByPrototypeRefParams{ctx, protoRef}

	// Record call args
	mmByPrototypeRef.ByPrototypeRefMock.mutex.Lock()
	mmByPrototypeRef.ByPrototypeRefMock.callArgs = append(mmByPrototypeRef.ByPrototypeRefMock.callArgs, mm_params)
	mmByPrototypeRef.ByPrototypeRefMock.mutex.Unlock()

	for _, e := range mmByPrototypeRef.ByPrototypeRefMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.c2, e.results.err
		}
	}

	if mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation.Counter, 1)
		mm_want := mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation.params
		mm_got := CacheMockByPrototypeRefParams{ctx, protoRef}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmByPrototypeRef.t.Errorf("CacheMock.ByPrototypeRef got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmByPrototypeRef.ByPrototypeRefMock.defaultExpectation.results
		if mm_results == nil {
			mmByPrototypeRef.t.Fatal("No results are set for the CacheMock.ByPrototypeRef")
		}
		return (*mm_results).p1, (*mm_results).c2, (*mm_results).err
	}
	if mmByPrototypeRef.funcByPrototypeRef != nil {
		return mmByPrototypeRef.funcByPrototypeRef(ctx, protoRef)
	}
	mmByPrototypeRef.t.Fatalf("Unexpected call to CacheMock.ByPrototypeRef. %v %v", ctx, protoRef)
	return
}

// ByPrototypeRefAfterCounter returns a count of finished CacheMock.ByPrototypeRef invocations
func (mmByPrototypeRef *CacheMock) ByPrototypeRefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByPrototypeRef.afterByPrototypeRefCounter)
}

// ByPrototypeRefBeforeCounter returns a count of CacheMock.ByPrototypeRef invocations
func (mmByPrototypeRef *CacheMock) ByPrototypeRefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByPrototypeRef.beforeByPrototypeRefCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.ByPrototypeRef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmByPrototypeRef *mCacheMockByPrototypeRef) Calls() []*CacheMockByPrototypeRefParams {
	mmByPrototypeRef.mutex.RLock()

	argCopy := make([]*CacheMockByPrototypeRefParams, len(mmByPrototypeRef.callArgs))
	copy(argCopy, mmByPrototypeRef.callArgs)

	mmByPrototypeRef.mutex.RUnlock()

	return argCopy
}

// MinimockByPrototypeRefDone returns true if the count of the ByPrototypeRef invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockByPrototypeRefDone() bool {
	for _, e := range m.ByPrototypeRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByPrototypeRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByPrototypeRef != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		return false
	}
	return true
}

// MinimockByPrototypeRefInspect logs each unmet expectation
func (m *CacheMock) MinimockByPrototypeRefInspect() {
	for _, e := range m.ByPrototypeRefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.ByPrototypeRef with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByPrototypeRefMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		if m.ByPrototypeRefMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.ByPrototypeRef")
		} else {
			m.t.Errorf("Expected call to CacheMock.ByPrototypeRef with params: %#v", *m.ByPrototypeRefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByPrototypeRef != nil && mm_atomic.LoadUint64(&m.afterByPrototypeRefCounter) < 1 {
		m.t.Error("Expected call to CacheMock.ByPrototypeRef")
	}
}

type mCacheMockGetCode struct {
	mock               *CacheMock
	defaultExpectation *CacheMockGetCodeExpectation
	expectations       []*CacheMockGetCodeExpectation

	callArgs []*CacheMockGetCodeParams
	mutex    sync.RWMutex
}

// CacheMockGetCodeExpectation specifies expectation struct of the Cache.GetCode
type CacheMockGetCodeExpectation struct {
	mock    *CacheMock
	params  *CacheMockGetCodeParams
	results *CacheMockGetCodeResults
	Counter uint64
}

// CacheMockGetCodeParams contains parameters of the Cache.GetCode
type CacheMockGetCodeParams struct {
	ctx context.Context
	ref insolar.Reference
}

// CacheMockGetCodeResults contains results of the Cache.GetCode
type CacheMockGetCodeResults struct {
	c2  CodeDescriptor
	err error
}

// Expect sets up expected params for Cache.GetCode
func (mmGetCode *mCacheMockGetCode) Expect(ctx context.Context, ref insolar.Reference) *mCacheMockGetCode {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("CacheMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &CacheMockGetCodeExpectation{}
	}

	mmGetCode.defaultExpectation.params = &CacheMockGetCodeParams{ctx, ref}
	for _, e := range mmGetCode.expectations {
		if minimock.Equal(e.params, mmGetCode.defaultExpectation.params) {
			mmGetCode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCode.defaultExpectation.params)
		}
	}

	return mmGetCode
}

// Inspect accepts an inspector function that has same arguments as the Cache.GetCode
func (mmGetCode *mCacheMockGetCode) Inspect(f func(ctx context.Context, ref insolar.Reference)) *mCacheMockGetCode {
	if mmGetCode.mock.inspectFuncGetCode != nil {
		mmGetCode.mock.t.Fatalf("Inspect function is already set for CacheMock.GetCode")
	}

	mmGetCode.mock.inspectFuncGetCode = f

	return mmGetCode
}

// Return sets up results that will be returned by Cache.GetCode
func (mmGetCode *mCacheMockGetCode) Return(c2 CodeDescriptor, err error) *CacheMock {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("CacheMock.GetCode mock is already set by Set")
	}

	if mmGetCode.defaultExpectation == nil {
		mmGetCode.defaultExpectation = &CacheMockGetCodeExpectation{mock: mmGetCode.mock}
	}
	mmGetCode.defaultExpectation.results = &CacheMockGetCodeResults{c2, err}
	return mmGetCode.mock
}

//Set uses given function f to mock the Cache.GetCode method
func (mmGetCode *mCacheMockGetCode) Set(f func(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error)) *CacheMock {
	if mmGetCode.defaultExpectation != nil {
		mmGetCode.mock.t.Fatalf("Default expectation is already set for the Cache.GetCode method")
	}

	if len(mmGetCode.expectations) > 0 {
		mmGetCode.mock.t.Fatalf("Some expectations are already set for the Cache.GetCode method")
	}

	mmGetCode.mock.funcGetCode = f
	return mmGetCode.mock
}

// When sets expectation for the Cache.GetCode which will trigger the result defined by the following
// Then helper
func (mmGetCode *mCacheMockGetCode) When(ctx context.Context, ref insolar.Reference) *CacheMockGetCodeExpectation {
	if mmGetCode.mock.funcGetCode != nil {
		mmGetCode.mock.t.Fatalf("CacheMock.GetCode mock is already set by Set")
	}

	expectation := &CacheMockGetCodeExpectation{
		mock:   mmGetCode.mock,
		params: &CacheMockGetCodeParams{ctx, ref},
	}
	mmGetCode.expectations = append(mmGetCode.expectations, expectation)
	return expectation
}

// Then sets up Cache.GetCode return parameters for the expectation previously defined by the When method
func (e *CacheMockGetCodeExpectation) Then(c2 CodeDescriptor, err error) *CacheMock {
	e.results = &CacheMockGetCodeResults{c2, err}
	return e.mock
}

// GetCode implements Cache
func (mmGetCode *CacheMock) GetCode(ctx context.Context, ref insolar.Reference) (c2 CodeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetCode.beforeGetCodeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCode.afterGetCodeCounter, 1)

	if mmGetCode.inspectFuncGetCode != nil {
		mmGetCode.inspectFuncGetCode(ctx, ref)
	}

	mm_params := &CacheMockGetCodeParams{ctx, ref}

	// Record call args
	mmGetCode.GetCodeMock.mutex.Lock()
	mmGetCode.GetCodeMock.callArgs = append(mmGetCode.GetCodeMock.callArgs, mm_params)
	mmGetCode.GetCodeMock.mutex.Unlock()

	for _, e := range mmGetCode.GetCodeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCode.GetCodeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCode.GetCodeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCode.GetCodeMock.defaultExpectation.params
		mm_got := CacheMockGetCodeParams{ctx, ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCode.t.Errorf("CacheMock.GetCode got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCode.GetCodeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCode.t.Fatal("No results are set for the CacheMock.GetCode")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCode.funcGetCode != nil {
		return mmGetCode.funcGetCode(ctx, ref)
	}
	mmGetCode.t.Fatalf("Unexpected call to CacheMock.GetCode. %v %v", ctx, ref)
	return
}

// GetCodeAfterCounter returns a count of finished CacheMock.GetCode invocations
func (mmGetCode *CacheMock) GetCodeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.afterGetCodeCounter)
}

// GetCodeBeforeCounter returns a count of CacheMock.GetCode invocations
func (mmGetCode *CacheMock) GetCodeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCode.beforeGetCodeCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.GetCode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCode *mCacheMockGetCode) Calls() []*CacheMockGetCodeParams {
	mmGetCode.mutex.RLock()

	argCopy := make([]*CacheMockGetCodeParams, len(mmGetCode.callArgs))
	copy(argCopy, mmGetCode.callArgs)

	mmGetCode.mutex.RUnlock()

	return argCopy
}

// MinimockGetCodeDone returns true if the count of the GetCode invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetCodeDone() bool {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCodeInspect logs each unmet expectation
func (m *CacheMock) MinimockGetCodeInspect() {
	for _, e := range m.GetCodeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.GetCode with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCodeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		if m.GetCodeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.GetCode")
		} else {
			m.t.Errorf("Expected call to CacheMock.GetCode with params: %#v", *m.GetCodeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCode != nil && mm_atomic.LoadUint64(&m.afterGetCodeCounter) < 1 {
		m.t.Error("Expected call to CacheMock.GetCode")
	}
}

type mCacheMockGetPrototype struct {
	mock               *CacheMock
	defaultExpectation *CacheMockGetPrototypeExpectation
	expectations       []*CacheMockGetPrototypeExpectation

	callArgs []*CacheMockGetPrototypeParams
	mutex    sync.RWMutex
}

// CacheMockGetPrototypeExpectation specifies expectation struct of the Cache.GetPrototype
type CacheMockGetPrototypeExpectation struct {
	mock    *CacheMock
	params  *CacheMockGetPrototypeParams
	results *CacheMockGetPrototypeResults
	Counter uint64
}

// CacheMockGetPrototypeParams contains parameters of the Cache.GetPrototype
type CacheMockGetPrototypeParams struct {
	ctx context.Context
	ref insolar.Reference
}

// CacheMockGetPrototypeResults contains results of the Cache.GetPrototype
type CacheMockGetPrototypeResults struct {
	p1  PrototypeDescriptor
	err error
}

// Expect sets up expected params for Cache.GetPrototype
func (mmGetPrototype *mCacheMockGetPrototype) Expect(ctx context.Context, ref insolar.Reference) *mCacheMockGetPrototype {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("CacheMock.GetPrototype mock is already set by Set")
	}

	if mmGetPrototype.defaultExpectation == nil {
		mmGetPrototype.defaultExpectation = &CacheMockGetPrototypeExpectation{}
	}

	mmGetPrototype.defaultExpectation.params = &CacheMockGetPrototypeParams{ctx, ref}
	for _, e := range mmGetPrototype.expectations {
		if minimock.Equal(e.params, mmGetPrototype.defaultExpectation.params) {
			mmGetPrototype.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPrototype.defaultExpectation.params)
		}
	}

	return mmGetPrototype
}

// Inspect accepts an inspector function that has same arguments as the Cache.GetPrototype
func (mmGetPrototype *mCacheMockGetPrototype) Inspect(f func(ctx context.Context, ref insolar.Reference)) *mCacheMockGetPrototype {
	if mmGetPrototype.mock.inspectFuncGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("Inspect function is already set for CacheMock.GetPrototype")
	}

	mmGetPrototype.mock.inspectFuncGetPrototype = f

	return mmGetPrototype
}

// Return sets up results that will be returned by Cache.GetPrototype
func (mmGetPrototype *mCacheMockGetPrototype) Return(p1 PrototypeDescriptor, err error) *CacheMock {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("CacheMock.GetPrototype mock is already set by Set")
	}

	if mmGetPrototype.defaultExpectation == nil {
		mmGetPrototype.defaultExpectation = &CacheMockGetPrototypeExpectation{mock: mmGetPrototype.mock}
	}
	mmGetPrototype.defaultExpectation.results = &CacheMockGetPrototypeResults{p1, err}
	return mmGetPrototype.mock
}

//Set uses given function f to mock the Cache.GetPrototype method
func (mmGetPrototype *mCacheMockGetPrototype) Set(f func(ctx context.Context, ref insolar.Reference) (p1 PrototypeDescriptor, err error)) *CacheMock {
	if mmGetPrototype.defaultExpectation != nil {
		mmGetPrototype.mock.t.Fatalf("Default expectation is already set for the Cache.GetPrototype method")
	}

	if len(mmGetPrototype.expectations) > 0 {
		mmGetPrototype.mock.t.Fatalf("Some expectations are already set for the Cache.GetPrototype method")
	}

	mmGetPrototype.mock.funcGetPrototype = f
	return mmGetPrototype.mock
}

// When sets expectation for the Cache.GetPrototype which will trigger the result defined by the following
// Then helper
func (mmGetPrototype *mCacheMockGetPrototype) When(ctx context.Context, ref insolar.Reference) *CacheMockGetPrototypeExpectation {
	if mmGetPrototype.mock.funcGetPrototype != nil {
		mmGetPrototype.mock.t.Fatalf("CacheMock.GetPrototype mock is already set by Set")
	}

	expectation := &CacheMockGetPrototypeExpectation{
		mock:   mmGetPrototype.mock,
		params: &CacheMockGetPrototypeParams{ctx, ref},
	}
	mmGetPrototype.expectations = append(mmGetPrototype.expectations, expectation)
	return expectation
}

// Then sets up Cache.GetPrototype return parameters for the expectation previously defined by the When method
func (e *CacheMockGetPrototypeExpectation) Then(p1 PrototypeDescriptor, err error) *CacheMock {
	e.results = &CacheMockGetPrototypeResults{p1, err}
	return e.mock
}

// GetPrototype implements Cache
func (mmGetPrototype *CacheMock) GetPrototype(ctx context.Context, ref insolar.Reference) (p1 PrototypeDescriptor, err error) {
	mm_atomic.AddUint64(&mmGetPrototype.beforeGetPrototypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrototype.afterGetPrototypeCounter, 1)

	if mmGetPrototype.inspectFuncGetPrototype != nil {
		mmGetPrototype.inspectFuncGetPrototype(ctx, ref)
	}

	mm_params := &CacheMockGetPrototypeParams{ctx, ref}

	// Record call args
	mmGetPrototype.GetPrototypeMock.mutex.Lock()
	mmGetPrototype.GetPrototypeMock.callArgs = append(mmGetPrototype.GetPrototypeMock.callArgs, mm_params)
	mmGetPrototype.GetPrototypeMock.mutex.Unlock()

	for _, e := range mmGetPrototype.GetPrototypeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPrototype.GetPrototypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrototype.GetPrototypeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPrototype.GetPrototypeMock.defaultExpectation.params
		mm_got := CacheMockGetPrototypeParams{ctx, ref}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPrototype.t.Errorf("CacheMock.GetPrototype got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPrototype.GetPrototypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPrototype.t.Fatal("No results are set for the CacheMock.GetPrototype")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPrototype.funcGetPrototype != nil {
		return mmGetPrototype.funcGetPrototype(ctx, ref)
	}
	mmGetPrototype.t.Fatalf("Unexpected call to CacheMock.GetPrototype. %v %v", ctx, ref)
	return
}

// GetPrototypeAfterCounter returns a count of finished CacheMock.GetPrototype invocations
func (mmGetPrototype *CacheMock) GetPrototypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrototype.afterGetPrototypeCounter)
}

// GetPrototypeBeforeCounter returns a count of CacheMock.GetPrototype invocations
func (mmGetPrototype *CacheMock) GetPrototypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrototype.beforeGetPrototypeCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.GetPrototype.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPrototype *mCacheMockGetPrototype) Calls() []*CacheMockGetPrototypeParams {
	mmGetPrototype.mutex.RLock()

	argCopy := make([]*CacheMockGetPrototypeParams, len(mmGetPrototype.callArgs))
	copy(argCopy, mmGetPrototype.callArgs)

	mmGetPrototype.mutex.RUnlock()

	return argCopy
}

// MinimockGetPrototypeDone returns true if the count of the GetPrototype invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetPrototypeDone() bool {
	for _, e := range m.GetPrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrototype != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPrototypeInspect logs each unmet expectation
func (m *CacheMock) MinimockGetPrototypeInspect() {
	for _, e := range m.GetPrototypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.GetPrototype with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrototypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		if m.GetPrototypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.GetPrototype")
		} else {
			m.t.Errorf("Expected call to CacheMock.GetPrototype with params: %#v", *m.GetPrototypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrototype != nil && mm_atomic.LoadUint64(&m.afterGetPrototypeCounter) < 1 {
		m.t.Error("Expected call to CacheMock.GetPrototype")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockByObjectDescriptorInspect()

		m.MinimockByPrototypeRefInspect()

		m.MinimockGetCodeInspect()

		m.MinimockGetPrototypeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockByObjectDescriptorDone() &&
		m.MinimockByPrototypeRefDone() &&
		m.MinimockGetCodeDone() &&
		m.MinimockGetPrototypeDone()
}
