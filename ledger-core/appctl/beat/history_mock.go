package beat

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
)

// HistoryMock implements History
type HistoryMock struct {
	t minimock.Tester

	funcLatestTimeBeat          func() (b1 Beat, err error)
	inspectFuncLatestTimeBeat   func()
	afterLatestTimeBeatCounter  uint64
	beforeLatestTimeBeatCounter uint64
	LatestTimeBeatMock          mHistoryMockLatestTimeBeat

	funcTimeBeat          func(n1 pulse.Number) (b1 Beat, err error)
	inspectFuncTimeBeat   func(n1 pulse.Number)
	afterTimeBeatCounter  uint64
	beforeTimeBeatCounter uint64
	TimeBeatMock          mHistoryMockTimeBeat
}

// NewHistoryMock returns a mock for History
func NewHistoryMock(t minimock.Tester) *HistoryMock {
	m := &HistoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LatestTimeBeatMock = mHistoryMockLatestTimeBeat{mock: m}

	m.TimeBeatMock = mHistoryMockTimeBeat{mock: m}
	m.TimeBeatMock.callArgs = []*HistoryMockTimeBeatParams{}

	return m
}

type mHistoryMockLatestTimeBeat struct {
	mock               *HistoryMock
	defaultExpectation *HistoryMockLatestTimeBeatExpectation
	expectations       []*HistoryMockLatestTimeBeatExpectation
}

// HistoryMockLatestTimeBeatExpectation specifies expectation struct of the History.LatestTimeBeat
type HistoryMockLatestTimeBeatExpectation struct {
	mock *HistoryMock

	results *HistoryMockLatestTimeBeatResults
	Counter uint64
}

// HistoryMockLatestTimeBeatResults contains results of the History.LatestTimeBeat
type HistoryMockLatestTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for History.LatestTimeBeat
func (mmLatestTimeBeat *mHistoryMockLatestTimeBeat) Expect() *mHistoryMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("HistoryMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &HistoryMockLatestTimeBeatExpectation{}
	}

	return mmLatestTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the History.LatestTimeBeat
func (mmLatestTimeBeat *mHistoryMockLatestTimeBeat) Inspect(f func()) *mHistoryMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Inspect function is already set for HistoryMock.LatestTimeBeat")
	}

	mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat = f

	return mmLatestTimeBeat
}

// Return sets up results that will be returned by History.LatestTimeBeat
func (mmLatestTimeBeat *mHistoryMockLatestTimeBeat) Return(b1 Beat, err error) *HistoryMock {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("HistoryMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &HistoryMockLatestTimeBeatExpectation{mock: mmLatestTimeBeat.mock}
	}
	mmLatestTimeBeat.defaultExpectation.results = &HistoryMockLatestTimeBeatResults{b1, err}
	return mmLatestTimeBeat.mock
}

//Set uses given function f to mock the History.LatestTimeBeat method
func (mmLatestTimeBeat *mHistoryMockLatestTimeBeat) Set(f func() (b1 Beat, err error)) *HistoryMock {
	if mmLatestTimeBeat.defaultExpectation != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Default expectation is already set for the History.LatestTimeBeat method")
	}

	if len(mmLatestTimeBeat.expectations) > 0 {
		mmLatestTimeBeat.mock.t.Fatalf("Some expectations are already set for the History.LatestTimeBeat method")
	}

	mmLatestTimeBeat.mock.funcLatestTimeBeat = f
	return mmLatestTimeBeat.mock
}

// LatestTimeBeat implements History
func (mmLatestTimeBeat *HistoryMock) LatestTimeBeat() (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter, 1)

	if mmLatestTimeBeat.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.inspectFuncLatestTimeBeat()
	}

	if mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.Counter, 1)

		mm_results := mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmLatestTimeBeat.t.Fatal("No results are set for the HistoryMock.LatestTimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmLatestTimeBeat.funcLatestTimeBeat != nil {
		return mmLatestTimeBeat.funcLatestTimeBeat()
	}
	mmLatestTimeBeat.t.Fatalf("Unexpected call to HistoryMock.LatestTimeBeat.")
	return
}

// LatestTimeBeatAfterCounter returns a count of finished HistoryMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *HistoryMock) LatestTimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter)
}

// LatestTimeBeatBeforeCounter returns a count of HistoryMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *HistoryMock) LatestTimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter)
}

// MinimockLatestTimeBeatDone returns true if the count of the LatestTimeBeat invocations corresponds
// the number of defined expectations
func (m *HistoryMock) MinimockLatestTimeBeatDone() bool {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockLatestTimeBeatInspect logs each unmet expectation
func (m *HistoryMock) MinimockLatestTimeBeatInspect() {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to HistoryMock.LatestTimeBeat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to HistoryMock.LatestTimeBeat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to HistoryMock.LatestTimeBeat")
	}
}

type mHistoryMockTimeBeat struct {
	mock               *HistoryMock
	defaultExpectation *HistoryMockTimeBeatExpectation
	expectations       []*HistoryMockTimeBeatExpectation

	callArgs []*HistoryMockTimeBeatParams
	mutex    sync.RWMutex
}

// HistoryMockTimeBeatExpectation specifies expectation struct of the History.TimeBeat
type HistoryMockTimeBeatExpectation struct {
	mock    *HistoryMock
	params  *HistoryMockTimeBeatParams
	results *HistoryMockTimeBeatResults
	Counter uint64
}

// HistoryMockTimeBeatParams contains parameters of the History.TimeBeat
type HistoryMockTimeBeatParams struct {
	n1 pulse.Number
}

// HistoryMockTimeBeatResults contains results of the History.TimeBeat
type HistoryMockTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for History.TimeBeat
func (mmTimeBeat *mHistoryMockTimeBeat) Expect(n1 pulse.Number) *mHistoryMockTimeBeat {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("HistoryMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &HistoryMockTimeBeatExpectation{}
	}

	mmTimeBeat.defaultExpectation.params = &HistoryMockTimeBeatParams{n1}
	for _, e := range mmTimeBeat.expectations {
		if minimock.Equal(e.params, mmTimeBeat.defaultExpectation.params) {
			mmTimeBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTimeBeat.defaultExpectation.params)
		}
	}

	return mmTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the History.TimeBeat
func (mmTimeBeat *mHistoryMockTimeBeat) Inspect(f func(n1 pulse.Number)) *mHistoryMockTimeBeat {
	if mmTimeBeat.mock.inspectFuncTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("Inspect function is already set for HistoryMock.TimeBeat")
	}

	mmTimeBeat.mock.inspectFuncTimeBeat = f

	return mmTimeBeat
}

// Return sets up results that will be returned by History.TimeBeat
func (mmTimeBeat *mHistoryMockTimeBeat) Return(b1 Beat, err error) *HistoryMock {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("HistoryMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &HistoryMockTimeBeatExpectation{mock: mmTimeBeat.mock}
	}
	mmTimeBeat.defaultExpectation.results = &HistoryMockTimeBeatResults{b1, err}
	return mmTimeBeat.mock
}

//Set uses given function f to mock the History.TimeBeat method
func (mmTimeBeat *mHistoryMockTimeBeat) Set(f func(n1 pulse.Number) (b1 Beat, err error)) *HistoryMock {
	if mmTimeBeat.defaultExpectation != nil {
		mmTimeBeat.mock.t.Fatalf("Default expectation is already set for the History.TimeBeat method")
	}

	if len(mmTimeBeat.expectations) > 0 {
		mmTimeBeat.mock.t.Fatalf("Some expectations are already set for the History.TimeBeat method")
	}

	mmTimeBeat.mock.funcTimeBeat = f
	return mmTimeBeat.mock
}

// When sets expectation for the History.TimeBeat which will trigger the result defined by the following
// Then helper
func (mmTimeBeat *mHistoryMockTimeBeat) When(n1 pulse.Number) *HistoryMockTimeBeatExpectation {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("HistoryMock.TimeBeat mock is already set by Set")
	}

	expectation := &HistoryMockTimeBeatExpectation{
		mock:   mmTimeBeat.mock,
		params: &HistoryMockTimeBeatParams{n1},
	}
	mmTimeBeat.expectations = append(mmTimeBeat.expectations, expectation)
	return expectation
}

// Then sets up History.TimeBeat return parameters for the expectation previously defined by the When method
func (e *HistoryMockTimeBeatExpectation) Then(b1 Beat, err error) *HistoryMock {
	e.results = &HistoryMockTimeBeatResults{b1, err}
	return e.mock
}

// TimeBeat implements History
func (mmTimeBeat *HistoryMock) TimeBeat(n1 pulse.Number) (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmTimeBeat.beforeTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmTimeBeat.afterTimeBeatCounter, 1)

	if mmTimeBeat.inspectFuncTimeBeat != nil {
		mmTimeBeat.inspectFuncTimeBeat(n1)
	}

	mm_params := &HistoryMockTimeBeatParams{n1}

	// Record call args
	mmTimeBeat.TimeBeatMock.mutex.Lock()
	mmTimeBeat.TimeBeatMock.callArgs = append(mmTimeBeat.TimeBeatMock.callArgs, mm_params)
	mmTimeBeat.TimeBeatMock.mutex.Unlock()

	for _, e := range mmTimeBeat.TimeBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmTimeBeat.TimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTimeBeat.TimeBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmTimeBeat.TimeBeatMock.defaultExpectation.params
		mm_got := HistoryMockTimeBeatParams{n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTimeBeat.t.Errorf("HistoryMock.TimeBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTimeBeat.TimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmTimeBeat.t.Fatal("No results are set for the HistoryMock.TimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmTimeBeat.funcTimeBeat != nil {
		return mmTimeBeat.funcTimeBeat(n1)
	}
	mmTimeBeat.t.Fatalf("Unexpected call to HistoryMock.TimeBeat. %v", n1)
	return
}

// TimeBeatAfterCounter returns a count of finished HistoryMock.TimeBeat invocations
func (mmTimeBeat *HistoryMock) TimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.afterTimeBeatCounter)
}

// TimeBeatBeforeCounter returns a count of HistoryMock.TimeBeat invocations
func (mmTimeBeat *HistoryMock) TimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.beforeTimeBeatCounter)
}

// Calls returns a list of arguments used in each call to HistoryMock.TimeBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTimeBeat *mHistoryMockTimeBeat) Calls() []*HistoryMockTimeBeatParams {
	mmTimeBeat.mutex.RLock()

	argCopy := make([]*HistoryMockTimeBeatParams, len(mmTimeBeat.callArgs))
	copy(argCopy, mmTimeBeat.callArgs)

	mmTimeBeat.mutex.RUnlock()

	return argCopy
}

// MinimockTimeBeatDone returns true if the count of the TimeBeat invocations corresponds
// the number of defined expectations
func (m *HistoryMock) MinimockTimeBeatDone() bool {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockTimeBeatInspect logs each unmet expectation
func (m *HistoryMock) MinimockTimeBeatInspect() {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HistoryMock.TimeBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		if m.TimeBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HistoryMock.TimeBeat")
		} else {
			m.t.Errorf("Expected call to HistoryMock.TimeBeat with params: %#v", *m.TimeBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		m.t.Error("Expected call to HistoryMock.TimeBeat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HistoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockLatestTimeBeatInspect()

		m.MinimockTimeBeatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HistoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HistoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLatestTimeBeatDone() &&
		m.MinimockTimeBeatDone()
}
