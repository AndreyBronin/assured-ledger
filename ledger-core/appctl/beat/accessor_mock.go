package beat

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
)

// AccessorMock implements Accessor
type AccessorMock struct {
	t minimock.Tester

	funcLatestTimeBeat          func() (b1 Beat, err error)
	inspectFuncLatestTimeBeat   func()
	afterLatestTimeBeatCounter  uint64
	beforeLatestTimeBeatCounter uint64
	LatestTimeBeatMock          mAccessorMockLatestTimeBeat

	funcTimeBeat          func(n1 pulse.Number) (b1 Beat, err error)
	inspectFuncTimeBeat   func(n1 pulse.Number)
	afterTimeBeatCounter  uint64
	beforeTimeBeatCounter uint64
	TimeBeatMock          mAccessorMockTimeBeat
}

// NewAccessorMock returns a mock for Accessor
func NewAccessorMock(t minimock.Tester) *AccessorMock {
	m := &AccessorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LatestTimeBeatMock = mAccessorMockLatestTimeBeat{mock: m}

	m.TimeBeatMock = mAccessorMockTimeBeat{mock: m}
	m.TimeBeatMock.callArgs = []*AccessorMockTimeBeatParams{}

	return m
}

type mAccessorMockLatestTimeBeat struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockLatestTimeBeatExpectation
	expectations       []*AccessorMockLatestTimeBeatExpectation
}

// AccessorMockLatestTimeBeatExpectation specifies expectation struct of the Accessor.LatestTimeBeat
type AccessorMockLatestTimeBeatExpectation struct {
	mock *AccessorMock

	results *AccessorMockLatestTimeBeatResults
	Counter uint64
}

// AccessorMockLatestTimeBeatResults contains results of the Accessor.LatestTimeBeat
type AccessorMockLatestTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for Accessor.LatestTimeBeat
func (mmLatestTimeBeat *mAccessorMockLatestTimeBeat) Expect() *mAccessorMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("AccessorMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &AccessorMockLatestTimeBeatExpectation{}
	}

	return mmLatestTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Accessor.LatestTimeBeat
func (mmLatestTimeBeat *mAccessorMockLatestTimeBeat) Inspect(f func()) *mAccessorMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Inspect function is already set for AccessorMock.LatestTimeBeat")
	}

	mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat = f

	return mmLatestTimeBeat
}

// Return sets up results that will be returned by Accessor.LatestTimeBeat
func (mmLatestTimeBeat *mAccessorMockLatestTimeBeat) Return(b1 Beat, err error) *AccessorMock {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("AccessorMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &AccessorMockLatestTimeBeatExpectation{mock: mmLatestTimeBeat.mock}
	}
	mmLatestTimeBeat.defaultExpectation.results = &AccessorMockLatestTimeBeatResults{b1, err}
	return mmLatestTimeBeat.mock
}

//Set uses given function f to mock the Accessor.LatestTimeBeat method
func (mmLatestTimeBeat *mAccessorMockLatestTimeBeat) Set(f func() (b1 Beat, err error)) *AccessorMock {
	if mmLatestTimeBeat.defaultExpectation != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Default expectation is already set for the Accessor.LatestTimeBeat method")
	}

	if len(mmLatestTimeBeat.expectations) > 0 {
		mmLatestTimeBeat.mock.t.Fatalf("Some expectations are already set for the Accessor.LatestTimeBeat method")
	}

	mmLatestTimeBeat.mock.funcLatestTimeBeat = f
	return mmLatestTimeBeat.mock
}

// LatestTimeBeat implements Accessor
func (mmLatestTimeBeat *AccessorMock) LatestTimeBeat() (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter, 1)

	if mmLatestTimeBeat.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.inspectFuncLatestTimeBeat()
	}

	if mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.Counter, 1)

		mm_results := mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmLatestTimeBeat.t.Fatal("No results are set for the AccessorMock.LatestTimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmLatestTimeBeat.funcLatestTimeBeat != nil {
		return mmLatestTimeBeat.funcLatestTimeBeat()
	}
	mmLatestTimeBeat.t.Fatalf("Unexpected call to AccessorMock.LatestTimeBeat.")
	return
}

// LatestTimeBeatAfterCounter returns a count of finished AccessorMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *AccessorMock) LatestTimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter)
}

// LatestTimeBeatBeforeCounter returns a count of AccessorMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *AccessorMock) LatestTimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter)
}

// MinimockLatestTimeBeatDone returns true if the count of the LatestTimeBeat invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockLatestTimeBeatDone() bool {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockLatestTimeBeatInspect logs each unmet expectation
func (m *AccessorMock) MinimockLatestTimeBeatInspect() {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AccessorMock.LatestTimeBeat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.LatestTimeBeat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.LatestTimeBeat")
	}
}

type mAccessorMockTimeBeat struct {
	mock               *AccessorMock
	defaultExpectation *AccessorMockTimeBeatExpectation
	expectations       []*AccessorMockTimeBeatExpectation

	callArgs []*AccessorMockTimeBeatParams
	mutex    sync.RWMutex
}

// AccessorMockTimeBeatExpectation specifies expectation struct of the Accessor.TimeBeat
type AccessorMockTimeBeatExpectation struct {
	mock    *AccessorMock
	params  *AccessorMockTimeBeatParams
	results *AccessorMockTimeBeatResults
	Counter uint64
}

// AccessorMockTimeBeatParams contains parameters of the Accessor.TimeBeat
type AccessorMockTimeBeatParams struct {
	n1 pulse.Number
}

// AccessorMockTimeBeatResults contains results of the Accessor.TimeBeat
type AccessorMockTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for Accessor.TimeBeat
func (mmTimeBeat *mAccessorMockTimeBeat) Expect(n1 pulse.Number) *mAccessorMockTimeBeat {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AccessorMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &AccessorMockTimeBeatExpectation{}
	}

	mmTimeBeat.defaultExpectation.params = &AccessorMockTimeBeatParams{n1}
	for _, e := range mmTimeBeat.expectations {
		if minimock.Equal(e.params, mmTimeBeat.defaultExpectation.params) {
			mmTimeBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTimeBeat.defaultExpectation.params)
		}
	}

	return mmTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Accessor.TimeBeat
func (mmTimeBeat *mAccessorMockTimeBeat) Inspect(f func(n1 pulse.Number)) *mAccessorMockTimeBeat {
	if mmTimeBeat.mock.inspectFuncTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("Inspect function is already set for AccessorMock.TimeBeat")
	}

	mmTimeBeat.mock.inspectFuncTimeBeat = f

	return mmTimeBeat
}

// Return sets up results that will be returned by Accessor.TimeBeat
func (mmTimeBeat *mAccessorMockTimeBeat) Return(b1 Beat, err error) *AccessorMock {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AccessorMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &AccessorMockTimeBeatExpectation{mock: mmTimeBeat.mock}
	}
	mmTimeBeat.defaultExpectation.results = &AccessorMockTimeBeatResults{b1, err}
	return mmTimeBeat.mock
}

//Set uses given function f to mock the Accessor.TimeBeat method
func (mmTimeBeat *mAccessorMockTimeBeat) Set(f func(n1 pulse.Number) (b1 Beat, err error)) *AccessorMock {
	if mmTimeBeat.defaultExpectation != nil {
		mmTimeBeat.mock.t.Fatalf("Default expectation is already set for the Accessor.TimeBeat method")
	}

	if len(mmTimeBeat.expectations) > 0 {
		mmTimeBeat.mock.t.Fatalf("Some expectations are already set for the Accessor.TimeBeat method")
	}

	mmTimeBeat.mock.funcTimeBeat = f
	return mmTimeBeat.mock
}

// When sets expectation for the Accessor.TimeBeat which will trigger the result defined by the following
// Then helper
func (mmTimeBeat *mAccessorMockTimeBeat) When(n1 pulse.Number) *AccessorMockTimeBeatExpectation {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AccessorMock.TimeBeat mock is already set by Set")
	}

	expectation := &AccessorMockTimeBeatExpectation{
		mock:   mmTimeBeat.mock,
		params: &AccessorMockTimeBeatParams{n1},
	}
	mmTimeBeat.expectations = append(mmTimeBeat.expectations, expectation)
	return expectation
}

// Then sets up Accessor.TimeBeat return parameters for the expectation previously defined by the When method
func (e *AccessorMockTimeBeatExpectation) Then(b1 Beat, err error) *AccessorMock {
	e.results = &AccessorMockTimeBeatResults{b1, err}
	return e.mock
}

// TimeBeat implements Accessor
func (mmTimeBeat *AccessorMock) TimeBeat(n1 pulse.Number) (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmTimeBeat.beforeTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmTimeBeat.afterTimeBeatCounter, 1)

	if mmTimeBeat.inspectFuncTimeBeat != nil {
		mmTimeBeat.inspectFuncTimeBeat(n1)
	}

	mm_params := &AccessorMockTimeBeatParams{n1}

	// Record call args
	mmTimeBeat.TimeBeatMock.mutex.Lock()
	mmTimeBeat.TimeBeatMock.callArgs = append(mmTimeBeat.TimeBeatMock.callArgs, mm_params)
	mmTimeBeat.TimeBeatMock.mutex.Unlock()

	for _, e := range mmTimeBeat.TimeBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmTimeBeat.TimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTimeBeat.TimeBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmTimeBeat.TimeBeatMock.defaultExpectation.params
		mm_got := AccessorMockTimeBeatParams{n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTimeBeat.t.Errorf("AccessorMock.TimeBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTimeBeat.TimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmTimeBeat.t.Fatal("No results are set for the AccessorMock.TimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmTimeBeat.funcTimeBeat != nil {
		return mmTimeBeat.funcTimeBeat(n1)
	}
	mmTimeBeat.t.Fatalf("Unexpected call to AccessorMock.TimeBeat. %v", n1)
	return
}

// TimeBeatAfterCounter returns a count of finished AccessorMock.TimeBeat invocations
func (mmTimeBeat *AccessorMock) TimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.afterTimeBeatCounter)
}

// TimeBeatBeforeCounter returns a count of AccessorMock.TimeBeat invocations
func (mmTimeBeat *AccessorMock) TimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.beforeTimeBeatCounter)
}

// Calls returns a list of arguments used in each call to AccessorMock.TimeBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTimeBeat *mAccessorMockTimeBeat) Calls() []*AccessorMockTimeBeatParams {
	mmTimeBeat.mutex.RLock()

	argCopy := make([]*AccessorMockTimeBeatParams, len(mmTimeBeat.callArgs))
	copy(argCopy, mmTimeBeat.callArgs)

	mmTimeBeat.mutex.RUnlock()

	return argCopy
}

// MinimockTimeBeatDone returns true if the count of the TimeBeat invocations corresponds
// the number of defined expectations
func (m *AccessorMock) MinimockTimeBeatDone() bool {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockTimeBeatInspect logs each unmet expectation
func (m *AccessorMock) MinimockTimeBeatInspect() {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessorMock.TimeBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		if m.TimeBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessorMock.TimeBeat")
		} else {
			m.t.Errorf("Expected call to AccessorMock.TimeBeat with params: %#v", *m.TimeBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AccessorMock.TimeBeat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccessorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockLatestTimeBeatInspect()

		m.MinimockTimeBeatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLatestTimeBeatDone() &&
		m.MinimockTimeBeatDone()
}
