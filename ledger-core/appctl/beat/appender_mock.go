package beat

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/assured-ledger/ledger-core/pulse"
)

// AppenderMock implements Appender
type AppenderMock struct {
	t minimock.Tester

	funcAddCommittedBeat          func(b1 Beat) (err error)
	inspectFuncAddCommittedBeat   func(b1 Beat)
	afterAddCommittedBeatCounter  uint64
	beforeAddCommittedBeatCounter uint64
	AddCommittedBeatMock          mAppenderMockAddCommittedBeat

	funcEnsureLatest          func(b1 Beat) (err error)
	inspectFuncEnsureLatest   func(b1 Beat)
	afterEnsureLatestCounter  uint64
	beforeEnsureLatestCounter uint64
	EnsureLatestMock          mAppenderMockEnsureLatest

	funcLatestTimeBeat          func() (b1 Beat, err error)
	inspectFuncLatestTimeBeat   func()
	afterLatestTimeBeatCounter  uint64
	beforeLatestTimeBeatCounter uint64
	LatestTimeBeatMock          mAppenderMockLatestTimeBeat

	funcTimeBeat          func(n1 pulse.Number) (b1 Beat, err error)
	inspectFuncTimeBeat   func(n1 pulse.Number)
	afterTimeBeatCounter  uint64
	beforeTimeBeatCounter uint64
	TimeBeatMock          mAppenderMockTimeBeat
}

// NewAppenderMock returns a mock for Appender
func NewAppenderMock(t minimock.Tester) *AppenderMock {
	m := &AppenderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCommittedBeatMock = mAppenderMockAddCommittedBeat{mock: m}
	m.AddCommittedBeatMock.callArgs = []*AppenderMockAddCommittedBeatParams{}

	m.EnsureLatestMock = mAppenderMockEnsureLatest{mock: m}
	m.EnsureLatestMock.callArgs = []*AppenderMockEnsureLatestParams{}

	m.LatestTimeBeatMock = mAppenderMockLatestTimeBeat{mock: m}

	m.TimeBeatMock = mAppenderMockTimeBeat{mock: m}
	m.TimeBeatMock.callArgs = []*AppenderMockTimeBeatParams{}

	return m
}

type mAppenderMockAddCommittedBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockAddCommittedBeatExpectation
	expectations       []*AppenderMockAddCommittedBeatExpectation

	callArgs []*AppenderMockAddCommittedBeatParams
	mutex    sync.RWMutex
}

// AppenderMockAddCommittedBeatExpectation specifies expectation struct of the Appender.AddCommittedBeat
type AppenderMockAddCommittedBeatExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockAddCommittedBeatParams
	results *AppenderMockAddCommittedBeatResults
	Counter uint64
}

// AppenderMockAddCommittedBeatParams contains parameters of the Appender.AddCommittedBeat
type AppenderMockAddCommittedBeatParams struct {
	b1 Beat
}

// AppenderMockAddCommittedBeatResults contains results of the Appender.AddCommittedBeat
type AppenderMockAddCommittedBeatResults struct {
	err error
}

// Expect sets up expected params for Appender.AddCommittedBeat
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Expect(b1 Beat) *mAppenderMockAddCommittedBeat {
	if mmAddCommittedBeat.mock.funcAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("AppenderMock.AddCommittedBeat mock is already set by Set")
	}

	if mmAddCommittedBeat.defaultExpectation == nil {
		mmAddCommittedBeat.defaultExpectation = &AppenderMockAddCommittedBeatExpectation{}
	}

	mmAddCommittedBeat.defaultExpectation.params = &AppenderMockAddCommittedBeatParams{b1}
	for _, e := range mmAddCommittedBeat.expectations {
		if minimock.Equal(e.params, mmAddCommittedBeat.defaultExpectation.params) {
			mmAddCommittedBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCommittedBeat.defaultExpectation.params)
		}
	}

	return mmAddCommittedBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.AddCommittedBeat
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Inspect(f func(b1 Beat)) *mAppenderMockAddCommittedBeat {
	if mmAddCommittedBeat.mock.inspectFuncAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.AddCommittedBeat")
	}

	mmAddCommittedBeat.mock.inspectFuncAddCommittedBeat = f

	return mmAddCommittedBeat
}

// Return sets up results that will be returned by Appender.AddCommittedBeat
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Return(err error) *AppenderMock {
	if mmAddCommittedBeat.mock.funcAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("AppenderMock.AddCommittedBeat mock is already set by Set")
	}

	if mmAddCommittedBeat.defaultExpectation == nil {
		mmAddCommittedBeat.defaultExpectation = &AppenderMockAddCommittedBeatExpectation{mock: mmAddCommittedBeat.mock}
	}
	mmAddCommittedBeat.defaultExpectation.results = &AppenderMockAddCommittedBeatResults{err}
	return mmAddCommittedBeat.mock
}

//Set uses given function f to mock the Appender.AddCommittedBeat method
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Set(f func(b1 Beat) (err error)) *AppenderMock {
	if mmAddCommittedBeat.defaultExpectation != nil {
		mmAddCommittedBeat.mock.t.Fatalf("Default expectation is already set for the Appender.AddCommittedBeat method")
	}

	if len(mmAddCommittedBeat.expectations) > 0 {
		mmAddCommittedBeat.mock.t.Fatalf("Some expectations are already set for the Appender.AddCommittedBeat method")
	}

	mmAddCommittedBeat.mock.funcAddCommittedBeat = f
	return mmAddCommittedBeat.mock
}

// When sets expectation for the Appender.AddCommittedBeat which will trigger the result defined by the following
// Then helper
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) When(b1 Beat) *AppenderMockAddCommittedBeatExpectation {
	if mmAddCommittedBeat.mock.funcAddCommittedBeat != nil {
		mmAddCommittedBeat.mock.t.Fatalf("AppenderMock.AddCommittedBeat mock is already set by Set")
	}

	expectation := &AppenderMockAddCommittedBeatExpectation{
		mock:   mmAddCommittedBeat.mock,
		params: &AppenderMockAddCommittedBeatParams{b1},
	}
	mmAddCommittedBeat.expectations = append(mmAddCommittedBeat.expectations, expectation)
	return expectation
}

// Then sets up Appender.AddCommittedBeat return parameters for the expectation previously defined by the When method
func (e *AppenderMockAddCommittedBeatExpectation) Then(err error) *AppenderMock {
	e.results = &AppenderMockAddCommittedBeatResults{err}
	return e.mock
}

// AddCommittedBeat implements Appender
func (mmAddCommittedBeat *AppenderMock) AddCommittedBeat(b1 Beat) (err error) {
	mm_atomic.AddUint64(&mmAddCommittedBeat.beforeAddCommittedBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCommittedBeat.afterAddCommittedBeatCounter, 1)

	if mmAddCommittedBeat.inspectFuncAddCommittedBeat != nil {
		mmAddCommittedBeat.inspectFuncAddCommittedBeat(b1)
	}

	mm_params := &AppenderMockAddCommittedBeatParams{b1}

	// Record call args
	mmAddCommittedBeat.AddCommittedBeatMock.mutex.Lock()
	mmAddCommittedBeat.AddCommittedBeatMock.callArgs = append(mmAddCommittedBeat.AddCommittedBeatMock.callArgs, mm_params)
	mmAddCommittedBeat.AddCommittedBeatMock.mutex.Unlock()

	for _, e := range mmAddCommittedBeat.AddCommittedBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation.params
		mm_got := AppenderMockAddCommittedBeatParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCommittedBeat.t.Errorf("AppenderMock.AddCommittedBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCommittedBeat.AddCommittedBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCommittedBeat.t.Fatal("No results are set for the AppenderMock.AddCommittedBeat")
		}
		return (*mm_results).err
	}
	if mmAddCommittedBeat.funcAddCommittedBeat != nil {
		return mmAddCommittedBeat.funcAddCommittedBeat(b1)
	}
	mmAddCommittedBeat.t.Fatalf("Unexpected call to AppenderMock.AddCommittedBeat. %v", b1)
	return
}

// AddCommittedBeatAfterCounter returns a count of finished AppenderMock.AddCommittedBeat invocations
func (mmAddCommittedBeat *AppenderMock) AddCommittedBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCommittedBeat.afterAddCommittedBeatCounter)
}

// AddCommittedBeatBeforeCounter returns a count of AppenderMock.AddCommittedBeat invocations
func (mmAddCommittedBeat *AppenderMock) AddCommittedBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCommittedBeat.beforeAddCommittedBeatCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.AddCommittedBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCommittedBeat *mAppenderMockAddCommittedBeat) Calls() []*AppenderMockAddCommittedBeatParams {
	mmAddCommittedBeat.mutex.RLock()

	argCopy := make([]*AppenderMockAddCommittedBeatParams, len(mmAddCommittedBeat.callArgs))
	copy(argCopy, mmAddCommittedBeat.callArgs)

	mmAddCommittedBeat.mutex.RUnlock()

	return argCopy
}

// MinimockAddCommittedBeatDone returns true if the count of the AddCommittedBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockAddCommittedBeatDone() bool {
	for _, e := range m.AddCommittedBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommittedBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCommittedBeat != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddCommittedBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockAddCommittedBeatInspect() {
	for _, e := range m.AddCommittedBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.AddCommittedBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommittedBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		if m.AddCommittedBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.AddCommittedBeat")
		} else {
			m.t.Errorf("Expected call to AppenderMock.AddCommittedBeat with params: %#v", *m.AddCommittedBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCommittedBeat != nil && mm_atomic.LoadUint64(&m.afterAddCommittedBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.AddCommittedBeat")
	}
}

type mAppenderMockEnsureLatest struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockEnsureLatestExpectation
	expectations       []*AppenderMockEnsureLatestExpectation

	callArgs []*AppenderMockEnsureLatestParams
	mutex    sync.RWMutex
}

// AppenderMockEnsureLatestExpectation specifies expectation struct of the Appender.EnsureLatest
type AppenderMockEnsureLatestExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockEnsureLatestParams
	results *AppenderMockEnsureLatestResults
	Counter uint64
}

// AppenderMockEnsureLatestParams contains parameters of the Appender.EnsureLatest
type AppenderMockEnsureLatestParams struct {
	b1 Beat
}

// AppenderMockEnsureLatestResults contains results of the Appender.EnsureLatest
type AppenderMockEnsureLatestResults struct {
	err error
}

// Expect sets up expected params for Appender.EnsureLatest
func (mmEnsureLatest *mAppenderMockEnsureLatest) Expect(b1 Beat) *mAppenderMockEnsureLatest {
	if mmEnsureLatest.mock.funcEnsureLatest != nil {
		mmEnsureLatest.mock.t.Fatalf("AppenderMock.EnsureLatest mock is already set by Set")
	}

	if mmEnsureLatest.defaultExpectation == nil {
		mmEnsureLatest.defaultExpectation = &AppenderMockEnsureLatestExpectation{}
	}

	mmEnsureLatest.defaultExpectation.params = &AppenderMockEnsureLatestParams{b1}
	for _, e := range mmEnsureLatest.expectations {
		if minimock.Equal(e.params, mmEnsureLatest.defaultExpectation.params) {
			mmEnsureLatest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnsureLatest.defaultExpectation.params)
		}
	}

	return mmEnsureLatest
}

// Inspect accepts an inspector function that has same arguments as the Appender.EnsureLatest
func (mmEnsureLatest *mAppenderMockEnsureLatest) Inspect(f func(b1 Beat)) *mAppenderMockEnsureLatest {
	if mmEnsureLatest.mock.inspectFuncEnsureLatest != nil {
		mmEnsureLatest.mock.t.Fatalf("Inspect function is already set for AppenderMock.EnsureLatest")
	}

	mmEnsureLatest.mock.inspectFuncEnsureLatest = f

	return mmEnsureLatest
}

// Return sets up results that will be returned by Appender.EnsureLatest
func (mmEnsureLatest *mAppenderMockEnsureLatest) Return(err error) *AppenderMock {
	if mmEnsureLatest.mock.funcEnsureLatest != nil {
		mmEnsureLatest.mock.t.Fatalf("AppenderMock.EnsureLatest mock is already set by Set")
	}

	if mmEnsureLatest.defaultExpectation == nil {
		mmEnsureLatest.defaultExpectation = &AppenderMockEnsureLatestExpectation{mock: mmEnsureLatest.mock}
	}
	mmEnsureLatest.defaultExpectation.results = &AppenderMockEnsureLatestResults{err}
	return mmEnsureLatest.mock
}

//Set uses given function f to mock the Appender.EnsureLatest method
func (mmEnsureLatest *mAppenderMockEnsureLatest) Set(f func(b1 Beat) (err error)) *AppenderMock {
	if mmEnsureLatest.defaultExpectation != nil {
		mmEnsureLatest.mock.t.Fatalf("Default expectation is already set for the Appender.EnsureLatest method")
	}

	if len(mmEnsureLatest.expectations) > 0 {
		mmEnsureLatest.mock.t.Fatalf("Some expectations are already set for the Appender.EnsureLatest method")
	}

	mmEnsureLatest.mock.funcEnsureLatest = f
	return mmEnsureLatest.mock
}

// When sets expectation for the Appender.EnsureLatest which will trigger the result defined by the following
// Then helper
func (mmEnsureLatest *mAppenderMockEnsureLatest) When(b1 Beat) *AppenderMockEnsureLatestExpectation {
	if mmEnsureLatest.mock.funcEnsureLatest != nil {
		mmEnsureLatest.mock.t.Fatalf("AppenderMock.EnsureLatest mock is already set by Set")
	}

	expectation := &AppenderMockEnsureLatestExpectation{
		mock:   mmEnsureLatest.mock,
		params: &AppenderMockEnsureLatestParams{b1},
	}
	mmEnsureLatest.expectations = append(mmEnsureLatest.expectations, expectation)
	return expectation
}

// Then sets up Appender.EnsureLatest return parameters for the expectation previously defined by the When method
func (e *AppenderMockEnsureLatestExpectation) Then(err error) *AppenderMock {
	e.results = &AppenderMockEnsureLatestResults{err}
	return e.mock
}

// EnsureLatest implements Appender
func (mmEnsureLatest *AppenderMock) EnsureLatest(b1 Beat) (err error) {
	mm_atomic.AddUint64(&mmEnsureLatest.beforeEnsureLatestCounter, 1)
	defer mm_atomic.AddUint64(&mmEnsureLatest.afterEnsureLatestCounter, 1)

	if mmEnsureLatest.inspectFuncEnsureLatest != nil {
		mmEnsureLatest.inspectFuncEnsureLatest(b1)
	}

	mm_params := &AppenderMockEnsureLatestParams{b1}

	// Record call args
	mmEnsureLatest.EnsureLatestMock.mutex.Lock()
	mmEnsureLatest.EnsureLatestMock.callArgs = append(mmEnsureLatest.EnsureLatestMock.callArgs, mm_params)
	mmEnsureLatest.EnsureLatestMock.mutex.Unlock()

	for _, e := range mmEnsureLatest.EnsureLatestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEnsureLatest.EnsureLatestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnsureLatest.EnsureLatestMock.defaultExpectation.Counter, 1)
		mm_want := mmEnsureLatest.EnsureLatestMock.defaultExpectation.params
		mm_got := AppenderMockEnsureLatestParams{b1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnsureLatest.t.Errorf("AppenderMock.EnsureLatest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEnsureLatest.EnsureLatestMock.defaultExpectation.results
		if mm_results == nil {
			mmEnsureLatest.t.Fatal("No results are set for the AppenderMock.EnsureLatest")
		}
		return (*mm_results).err
	}
	if mmEnsureLatest.funcEnsureLatest != nil {
		return mmEnsureLatest.funcEnsureLatest(b1)
	}
	mmEnsureLatest.t.Fatalf("Unexpected call to AppenderMock.EnsureLatest. %v", b1)
	return
}

// EnsureLatestAfterCounter returns a count of finished AppenderMock.EnsureLatest invocations
func (mmEnsureLatest *AppenderMock) EnsureLatestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnsureLatest.afterEnsureLatestCounter)
}

// EnsureLatestBeforeCounter returns a count of AppenderMock.EnsureLatest invocations
func (mmEnsureLatest *AppenderMock) EnsureLatestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnsureLatest.beforeEnsureLatestCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.EnsureLatest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnsureLatest *mAppenderMockEnsureLatest) Calls() []*AppenderMockEnsureLatestParams {
	mmEnsureLatest.mutex.RLock()

	argCopy := make([]*AppenderMockEnsureLatestParams, len(mmEnsureLatest.callArgs))
	copy(argCopy, mmEnsureLatest.callArgs)

	mmEnsureLatest.mutex.RUnlock()

	return argCopy
}

// MinimockEnsureLatestDone returns true if the count of the EnsureLatest invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockEnsureLatestDone() bool {
	for _, e := range m.EnsureLatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnsureLatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnsureLatest != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestCounter) < 1 {
		return false
	}
	return true
}

// MinimockEnsureLatestInspect logs each unmet expectation
func (m *AppenderMock) MinimockEnsureLatestInspect() {
	for _, e := range m.EnsureLatestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.EnsureLatest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnsureLatestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestCounter) < 1 {
		if m.EnsureLatestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.EnsureLatest")
		} else {
			m.t.Errorf("Expected call to AppenderMock.EnsureLatest with params: %#v", *m.EnsureLatestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnsureLatest != nil && mm_atomic.LoadUint64(&m.afterEnsureLatestCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.EnsureLatest")
	}
}

type mAppenderMockLatestTimeBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockLatestTimeBeatExpectation
	expectations       []*AppenderMockLatestTimeBeatExpectation
}

// AppenderMockLatestTimeBeatExpectation specifies expectation struct of the Appender.LatestTimeBeat
type AppenderMockLatestTimeBeatExpectation struct {
	mock *AppenderMock

	results *AppenderMockLatestTimeBeatResults
	Counter uint64
}

// AppenderMockLatestTimeBeatResults contains results of the Appender.LatestTimeBeat
type AppenderMockLatestTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for Appender.LatestTimeBeat
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Expect() *mAppenderMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("AppenderMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &AppenderMockLatestTimeBeatExpectation{}
	}

	return mmLatestTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.LatestTimeBeat
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Inspect(f func()) *mAppenderMockLatestTimeBeat {
	if mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.LatestTimeBeat")
	}

	mmLatestTimeBeat.mock.inspectFuncLatestTimeBeat = f

	return mmLatestTimeBeat
}

// Return sets up results that will be returned by Appender.LatestTimeBeat
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Return(b1 Beat, err error) *AppenderMock {
	if mmLatestTimeBeat.mock.funcLatestTimeBeat != nil {
		mmLatestTimeBeat.mock.t.Fatalf("AppenderMock.LatestTimeBeat mock is already set by Set")
	}

	if mmLatestTimeBeat.defaultExpectation == nil {
		mmLatestTimeBeat.defaultExpectation = &AppenderMockLatestTimeBeatExpectation{mock: mmLatestTimeBeat.mock}
	}
	mmLatestTimeBeat.defaultExpectation.results = &AppenderMockLatestTimeBeatResults{b1, err}
	return mmLatestTimeBeat.mock
}

//Set uses given function f to mock the Appender.LatestTimeBeat method
func (mmLatestTimeBeat *mAppenderMockLatestTimeBeat) Set(f func() (b1 Beat, err error)) *AppenderMock {
	if mmLatestTimeBeat.defaultExpectation != nil {
		mmLatestTimeBeat.mock.t.Fatalf("Default expectation is already set for the Appender.LatestTimeBeat method")
	}

	if len(mmLatestTimeBeat.expectations) > 0 {
		mmLatestTimeBeat.mock.t.Fatalf("Some expectations are already set for the Appender.LatestTimeBeat method")
	}

	mmLatestTimeBeat.mock.funcLatestTimeBeat = f
	return mmLatestTimeBeat.mock
}

// LatestTimeBeat implements Appender
func (mmLatestTimeBeat *AppenderMock) LatestTimeBeat() (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter, 1)

	if mmLatestTimeBeat.inspectFuncLatestTimeBeat != nil {
		mmLatestTimeBeat.inspectFuncLatestTimeBeat()
	}

	if mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.Counter, 1)

		mm_results := mmLatestTimeBeat.LatestTimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmLatestTimeBeat.t.Fatal("No results are set for the AppenderMock.LatestTimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmLatestTimeBeat.funcLatestTimeBeat != nil {
		return mmLatestTimeBeat.funcLatestTimeBeat()
	}
	mmLatestTimeBeat.t.Fatalf("Unexpected call to AppenderMock.LatestTimeBeat.")
	return
}

// LatestTimeBeatAfterCounter returns a count of finished AppenderMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *AppenderMock) LatestTimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.afterLatestTimeBeatCounter)
}

// LatestTimeBeatBeforeCounter returns a count of AppenderMock.LatestTimeBeat invocations
func (mmLatestTimeBeat *AppenderMock) LatestTimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLatestTimeBeat.beforeLatestTimeBeatCounter)
}

// MinimockLatestTimeBeatDone returns true if the count of the LatestTimeBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockLatestTimeBeatDone() bool {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockLatestTimeBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockLatestTimeBeatInspect() {
	for _, e := range m.LatestTimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AppenderMock.LatestTimeBeat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LatestTimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.LatestTimeBeat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLatestTimeBeat != nil && mm_atomic.LoadUint64(&m.afterLatestTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.LatestTimeBeat")
	}
}

type mAppenderMockTimeBeat struct {
	mock               *AppenderMock
	defaultExpectation *AppenderMockTimeBeatExpectation
	expectations       []*AppenderMockTimeBeatExpectation

	callArgs []*AppenderMockTimeBeatParams
	mutex    sync.RWMutex
}

// AppenderMockTimeBeatExpectation specifies expectation struct of the Appender.TimeBeat
type AppenderMockTimeBeatExpectation struct {
	mock    *AppenderMock
	params  *AppenderMockTimeBeatParams
	results *AppenderMockTimeBeatResults
	Counter uint64
}

// AppenderMockTimeBeatParams contains parameters of the Appender.TimeBeat
type AppenderMockTimeBeatParams struct {
	n1 pulse.Number
}

// AppenderMockTimeBeatResults contains results of the Appender.TimeBeat
type AppenderMockTimeBeatResults struct {
	b1  Beat
	err error
}

// Expect sets up expected params for Appender.TimeBeat
func (mmTimeBeat *mAppenderMockTimeBeat) Expect(n1 pulse.Number) *mAppenderMockTimeBeat {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AppenderMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &AppenderMockTimeBeatExpectation{}
	}

	mmTimeBeat.defaultExpectation.params = &AppenderMockTimeBeatParams{n1}
	for _, e := range mmTimeBeat.expectations {
		if minimock.Equal(e.params, mmTimeBeat.defaultExpectation.params) {
			mmTimeBeat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTimeBeat.defaultExpectation.params)
		}
	}

	return mmTimeBeat
}

// Inspect accepts an inspector function that has same arguments as the Appender.TimeBeat
func (mmTimeBeat *mAppenderMockTimeBeat) Inspect(f func(n1 pulse.Number)) *mAppenderMockTimeBeat {
	if mmTimeBeat.mock.inspectFuncTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("Inspect function is already set for AppenderMock.TimeBeat")
	}

	mmTimeBeat.mock.inspectFuncTimeBeat = f

	return mmTimeBeat
}

// Return sets up results that will be returned by Appender.TimeBeat
func (mmTimeBeat *mAppenderMockTimeBeat) Return(b1 Beat, err error) *AppenderMock {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AppenderMock.TimeBeat mock is already set by Set")
	}

	if mmTimeBeat.defaultExpectation == nil {
		mmTimeBeat.defaultExpectation = &AppenderMockTimeBeatExpectation{mock: mmTimeBeat.mock}
	}
	mmTimeBeat.defaultExpectation.results = &AppenderMockTimeBeatResults{b1, err}
	return mmTimeBeat.mock
}

//Set uses given function f to mock the Appender.TimeBeat method
func (mmTimeBeat *mAppenderMockTimeBeat) Set(f func(n1 pulse.Number) (b1 Beat, err error)) *AppenderMock {
	if mmTimeBeat.defaultExpectation != nil {
		mmTimeBeat.mock.t.Fatalf("Default expectation is already set for the Appender.TimeBeat method")
	}

	if len(mmTimeBeat.expectations) > 0 {
		mmTimeBeat.mock.t.Fatalf("Some expectations are already set for the Appender.TimeBeat method")
	}

	mmTimeBeat.mock.funcTimeBeat = f
	return mmTimeBeat.mock
}

// When sets expectation for the Appender.TimeBeat which will trigger the result defined by the following
// Then helper
func (mmTimeBeat *mAppenderMockTimeBeat) When(n1 pulse.Number) *AppenderMockTimeBeatExpectation {
	if mmTimeBeat.mock.funcTimeBeat != nil {
		mmTimeBeat.mock.t.Fatalf("AppenderMock.TimeBeat mock is already set by Set")
	}

	expectation := &AppenderMockTimeBeatExpectation{
		mock:   mmTimeBeat.mock,
		params: &AppenderMockTimeBeatParams{n1},
	}
	mmTimeBeat.expectations = append(mmTimeBeat.expectations, expectation)
	return expectation
}

// Then sets up Appender.TimeBeat return parameters for the expectation previously defined by the When method
func (e *AppenderMockTimeBeatExpectation) Then(b1 Beat, err error) *AppenderMock {
	e.results = &AppenderMockTimeBeatResults{b1, err}
	return e.mock
}

// TimeBeat implements Appender
func (mmTimeBeat *AppenderMock) TimeBeat(n1 pulse.Number) (b1 Beat, err error) {
	mm_atomic.AddUint64(&mmTimeBeat.beforeTimeBeatCounter, 1)
	defer mm_atomic.AddUint64(&mmTimeBeat.afterTimeBeatCounter, 1)

	if mmTimeBeat.inspectFuncTimeBeat != nil {
		mmTimeBeat.inspectFuncTimeBeat(n1)
	}

	mm_params := &AppenderMockTimeBeatParams{n1}

	// Record call args
	mmTimeBeat.TimeBeatMock.mutex.Lock()
	mmTimeBeat.TimeBeatMock.callArgs = append(mmTimeBeat.TimeBeatMock.callArgs, mm_params)
	mmTimeBeat.TimeBeatMock.mutex.Unlock()

	for _, e := range mmTimeBeat.TimeBeatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmTimeBeat.TimeBeatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTimeBeat.TimeBeatMock.defaultExpectation.Counter, 1)
		mm_want := mmTimeBeat.TimeBeatMock.defaultExpectation.params
		mm_got := AppenderMockTimeBeatParams{n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTimeBeat.t.Errorf("AppenderMock.TimeBeat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTimeBeat.TimeBeatMock.defaultExpectation.results
		if mm_results == nil {
			mmTimeBeat.t.Fatal("No results are set for the AppenderMock.TimeBeat")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmTimeBeat.funcTimeBeat != nil {
		return mmTimeBeat.funcTimeBeat(n1)
	}
	mmTimeBeat.t.Fatalf("Unexpected call to AppenderMock.TimeBeat. %v", n1)
	return
}

// TimeBeatAfterCounter returns a count of finished AppenderMock.TimeBeat invocations
func (mmTimeBeat *AppenderMock) TimeBeatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.afterTimeBeatCounter)
}

// TimeBeatBeforeCounter returns a count of AppenderMock.TimeBeat invocations
func (mmTimeBeat *AppenderMock) TimeBeatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTimeBeat.beforeTimeBeatCounter)
}

// Calls returns a list of arguments used in each call to AppenderMock.TimeBeat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTimeBeat *mAppenderMockTimeBeat) Calls() []*AppenderMockTimeBeatParams {
	mmTimeBeat.mutex.RLock()

	argCopy := make([]*AppenderMockTimeBeatParams, len(mmTimeBeat.callArgs))
	copy(argCopy, mmTimeBeat.callArgs)

	mmTimeBeat.mutex.RUnlock()

	return argCopy
}

// MinimockTimeBeatDone returns true if the count of the TimeBeat invocations corresponds
// the number of defined expectations
func (m *AppenderMock) MinimockTimeBeatDone() bool {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		return false
	}
	return true
}

// MinimockTimeBeatInspect logs each unmet expectation
func (m *AppenderMock) MinimockTimeBeatInspect() {
	for _, e := range m.TimeBeatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppenderMock.TimeBeat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TimeBeatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		if m.TimeBeatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AppenderMock.TimeBeat")
		} else {
			m.t.Errorf("Expected call to AppenderMock.TimeBeat with params: %#v", *m.TimeBeatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTimeBeat != nil && mm_atomic.LoadUint64(&m.afterTimeBeatCounter) < 1 {
		m.t.Error("Expected call to AppenderMock.TimeBeat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AppenderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddCommittedBeatInspect()

		m.MinimockEnsureLatestInspect()

		m.MinimockLatestTimeBeatInspect()

		m.MinimockTimeBeatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AppenderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AppenderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCommittedBeatDone() &&
		m.MinimockEnsureLatestDone() &&
		m.MinimockLatestTimeBeatDone() &&
		m.MinimockTimeBeatDone()
}
