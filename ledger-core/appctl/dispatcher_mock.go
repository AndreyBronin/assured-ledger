package appctl

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DispatcherMock implements Dispatcher
type DispatcherMock struct {
	t minimock.Tester

	funcCancelPulseChange          func()
	inspectFuncCancelPulseChange   func()
	afterCancelPulseChangeCounter  uint64
	beforeCancelPulseChangeCounter uint64
	CancelPulseChangeMock          mDispatcherMockCancelPulseChange

	funcCommitPulseChange          func(p1 PulseChange)
	inspectFuncCommitPulseChange   func(p1 PulseChange)
	afterCommitPulseChangeCounter  uint64
	beforeCommitPulseChangeCounter uint64
	CommitPulseChangeMock          mDispatcherMockCommitPulseChange

	funcPreparePulseChange          func(p1 PulseChange, n1 NodeStateSink)
	inspectFuncPreparePulseChange   func(p1 PulseChange, n1 NodeStateSink)
	afterPreparePulseChangeCounter  uint64
	beforePreparePulseChangeCounter uint64
	PreparePulseChangeMock          mDispatcherMockPreparePulseChange

	funcProcess          func(msg *Message) (err error)
	inspectFuncProcess   func(msg *Message)
	afterProcessCounter  uint64
	beforeProcessCounter uint64
	ProcessMock          mDispatcherMockProcess
}

// NewDispatcherMock returns a mock for Dispatcher
func NewDispatcherMock(t minimock.Tester) *DispatcherMock {
	m := &DispatcherMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelPulseChangeMock = mDispatcherMockCancelPulseChange{mock: m}

	m.CommitPulseChangeMock = mDispatcherMockCommitPulseChange{mock: m}
	m.CommitPulseChangeMock.callArgs = []*DispatcherMockCommitPulseChangeParams{}

	m.PreparePulseChangeMock = mDispatcherMockPreparePulseChange{mock: m}
	m.PreparePulseChangeMock.callArgs = []*DispatcherMockPreparePulseChangeParams{}

	m.ProcessMock = mDispatcherMockProcess{mock: m}
	m.ProcessMock.callArgs = []*DispatcherMockProcessParams{}

	return m
}

type mDispatcherMockCancelPulseChange struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockCancelPulseChangeExpectation
	expectations       []*DispatcherMockCancelPulseChangeExpectation
}

// DispatcherMockCancelPulseChangeExpectation specifies expectation struct of the Dispatcher.CancelPulseChange
type DispatcherMockCancelPulseChangeExpectation struct {
	mock *DispatcherMock

	Counter uint64
}

// Expect sets up expected params for Dispatcher.CancelPulseChange
func (mmCancelPulseChange *mDispatcherMockCancelPulseChange) Expect() *mDispatcherMockCancelPulseChange {
	if mmCancelPulseChange.mock.funcCancelPulseChange != nil {
		mmCancelPulseChange.mock.t.Fatalf("DispatcherMock.CancelPulseChange mock is already set by Set")
	}

	if mmCancelPulseChange.defaultExpectation == nil {
		mmCancelPulseChange.defaultExpectation = &DispatcherMockCancelPulseChangeExpectation{}
	}

	return mmCancelPulseChange
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.CancelPulseChange
func (mmCancelPulseChange *mDispatcherMockCancelPulseChange) Inspect(f func()) *mDispatcherMockCancelPulseChange {
	if mmCancelPulseChange.mock.inspectFuncCancelPulseChange != nil {
		mmCancelPulseChange.mock.t.Fatalf("Inspect function is already set for DispatcherMock.CancelPulseChange")
	}

	mmCancelPulseChange.mock.inspectFuncCancelPulseChange = f

	return mmCancelPulseChange
}

// Return sets up results that will be returned by Dispatcher.CancelPulseChange
func (mmCancelPulseChange *mDispatcherMockCancelPulseChange) Return() *DispatcherMock {
	if mmCancelPulseChange.mock.funcCancelPulseChange != nil {
		mmCancelPulseChange.mock.t.Fatalf("DispatcherMock.CancelPulseChange mock is already set by Set")
	}

	if mmCancelPulseChange.defaultExpectation == nil {
		mmCancelPulseChange.defaultExpectation = &DispatcherMockCancelPulseChangeExpectation{mock: mmCancelPulseChange.mock}
	}

	return mmCancelPulseChange.mock
}

//Set uses given function f to mock the Dispatcher.CancelPulseChange method
func (mmCancelPulseChange *mDispatcherMockCancelPulseChange) Set(f func()) *DispatcherMock {
	if mmCancelPulseChange.defaultExpectation != nil {
		mmCancelPulseChange.mock.t.Fatalf("Default expectation is already set for the Dispatcher.CancelPulseChange method")
	}

	if len(mmCancelPulseChange.expectations) > 0 {
		mmCancelPulseChange.mock.t.Fatalf("Some expectations are already set for the Dispatcher.CancelPulseChange method")
	}

	mmCancelPulseChange.mock.funcCancelPulseChange = f
	return mmCancelPulseChange.mock
}

// CancelPulseChange implements Dispatcher
func (mmCancelPulseChange *DispatcherMock) CancelPulseChange() {
	mm_atomic.AddUint64(&mmCancelPulseChange.beforeCancelPulseChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelPulseChange.afterCancelPulseChangeCounter, 1)

	if mmCancelPulseChange.inspectFuncCancelPulseChange != nil {
		mmCancelPulseChange.inspectFuncCancelPulseChange()
	}

	if mmCancelPulseChange.CancelPulseChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelPulseChange.CancelPulseChangeMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCancelPulseChange.funcCancelPulseChange != nil {
		mmCancelPulseChange.funcCancelPulseChange()
		return
	}
	mmCancelPulseChange.t.Fatalf("Unexpected call to DispatcherMock.CancelPulseChange.")

}

// CancelPulseChangeAfterCounter returns a count of finished DispatcherMock.CancelPulseChange invocations
func (mmCancelPulseChange *DispatcherMock) CancelPulseChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelPulseChange.afterCancelPulseChangeCounter)
}

// CancelPulseChangeBeforeCounter returns a count of DispatcherMock.CancelPulseChange invocations
func (mmCancelPulseChange *DispatcherMock) CancelPulseChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelPulseChange.beforeCancelPulseChangeCounter)
}

// MinimockCancelPulseChangeDone returns true if the count of the CancelPulseChange invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockCancelPulseChangeDone() bool {
	for _, e := range m.CancelPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelPulseChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelPulseChange != nil && mm_atomic.LoadUint64(&m.afterCancelPulseChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelPulseChangeInspect logs each unmet expectation
func (m *DispatcherMock) MinimockCancelPulseChangeInspect() {
	for _, e := range m.CancelPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DispatcherMock.CancelPulseChange")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelPulseChangeCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.CancelPulseChange")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelPulseChange != nil && mm_atomic.LoadUint64(&m.afterCancelPulseChangeCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.CancelPulseChange")
	}
}

type mDispatcherMockCommitPulseChange struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockCommitPulseChangeExpectation
	expectations       []*DispatcherMockCommitPulseChangeExpectation

	callArgs []*DispatcherMockCommitPulseChangeParams
	mutex    sync.RWMutex
}

// DispatcherMockCommitPulseChangeExpectation specifies expectation struct of the Dispatcher.CommitPulseChange
type DispatcherMockCommitPulseChangeExpectation struct {
	mock   *DispatcherMock
	params *DispatcherMockCommitPulseChangeParams

	Counter uint64
}

// DispatcherMockCommitPulseChangeParams contains parameters of the Dispatcher.CommitPulseChange
type DispatcherMockCommitPulseChangeParams struct {
	p1 PulseChange
}

// Expect sets up expected params for Dispatcher.CommitPulseChange
func (mmCommitPulseChange *mDispatcherMockCommitPulseChange) Expect(p1 PulseChange) *mDispatcherMockCommitPulseChange {
	if mmCommitPulseChange.mock.funcCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("DispatcherMock.CommitPulseChange mock is already set by Set")
	}

	if mmCommitPulseChange.defaultExpectation == nil {
		mmCommitPulseChange.defaultExpectation = &DispatcherMockCommitPulseChangeExpectation{}
	}

	mmCommitPulseChange.defaultExpectation.params = &DispatcherMockCommitPulseChangeParams{p1}
	for _, e := range mmCommitPulseChange.expectations {
		if minimock.Equal(e.params, mmCommitPulseChange.defaultExpectation.params) {
			mmCommitPulseChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommitPulseChange.defaultExpectation.params)
		}
	}

	return mmCommitPulseChange
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.CommitPulseChange
func (mmCommitPulseChange *mDispatcherMockCommitPulseChange) Inspect(f func(p1 PulseChange)) *mDispatcherMockCommitPulseChange {
	if mmCommitPulseChange.mock.inspectFuncCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("Inspect function is already set for DispatcherMock.CommitPulseChange")
	}

	mmCommitPulseChange.mock.inspectFuncCommitPulseChange = f

	return mmCommitPulseChange
}

// Return sets up results that will be returned by Dispatcher.CommitPulseChange
func (mmCommitPulseChange *mDispatcherMockCommitPulseChange) Return() *DispatcherMock {
	if mmCommitPulseChange.mock.funcCommitPulseChange != nil {
		mmCommitPulseChange.mock.t.Fatalf("DispatcherMock.CommitPulseChange mock is already set by Set")
	}

	if mmCommitPulseChange.defaultExpectation == nil {
		mmCommitPulseChange.defaultExpectation = &DispatcherMockCommitPulseChangeExpectation{mock: mmCommitPulseChange.mock}
	}

	return mmCommitPulseChange.mock
}

//Set uses given function f to mock the Dispatcher.CommitPulseChange method
func (mmCommitPulseChange *mDispatcherMockCommitPulseChange) Set(f func(p1 PulseChange)) *DispatcherMock {
	if mmCommitPulseChange.defaultExpectation != nil {
		mmCommitPulseChange.mock.t.Fatalf("Default expectation is already set for the Dispatcher.CommitPulseChange method")
	}

	if len(mmCommitPulseChange.expectations) > 0 {
		mmCommitPulseChange.mock.t.Fatalf("Some expectations are already set for the Dispatcher.CommitPulseChange method")
	}

	mmCommitPulseChange.mock.funcCommitPulseChange = f
	return mmCommitPulseChange.mock
}

// CommitPulseChange implements Dispatcher
func (mmCommitPulseChange *DispatcherMock) CommitPulseChange(p1 PulseChange) {
	mm_atomic.AddUint64(&mmCommitPulseChange.beforeCommitPulseChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitPulseChange.afterCommitPulseChangeCounter, 1)

	if mmCommitPulseChange.inspectFuncCommitPulseChange != nil {
		mmCommitPulseChange.inspectFuncCommitPulseChange(p1)
	}

	mm_params := &DispatcherMockCommitPulseChangeParams{p1}

	// Record call args
	mmCommitPulseChange.CommitPulseChangeMock.mutex.Lock()
	mmCommitPulseChange.CommitPulseChangeMock.callArgs = append(mmCommitPulseChange.CommitPulseChangeMock.callArgs, mm_params)
	mmCommitPulseChange.CommitPulseChangeMock.mutex.Unlock()

	for _, e := range mmCommitPulseChange.CommitPulseChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmCommitPulseChange.CommitPulseChangeMock.defaultExpectation.params
		mm_got := DispatcherMockCommitPulseChangeParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommitPulseChange.t.Errorf("DispatcherMock.CommitPulseChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCommitPulseChange.funcCommitPulseChange != nil {
		mmCommitPulseChange.funcCommitPulseChange(p1)
		return
	}
	mmCommitPulseChange.t.Fatalf("Unexpected call to DispatcherMock.CommitPulseChange. %v", p1)

}

// CommitPulseChangeAfterCounter returns a count of finished DispatcherMock.CommitPulseChange invocations
func (mmCommitPulseChange *DispatcherMock) CommitPulseChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitPulseChange.afterCommitPulseChangeCounter)
}

// CommitPulseChangeBeforeCounter returns a count of DispatcherMock.CommitPulseChange invocations
func (mmCommitPulseChange *DispatcherMock) CommitPulseChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitPulseChange.beforeCommitPulseChangeCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.CommitPulseChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommitPulseChange *mDispatcherMockCommitPulseChange) Calls() []*DispatcherMockCommitPulseChangeParams {
	mmCommitPulseChange.mutex.RLock()

	argCopy := make([]*DispatcherMockCommitPulseChangeParams, len(mmCommitPulseChange.callArgs))
	copy(argCopy, mmCommitPulseChange.callArgs)

	mmCommitPulseChange.mutex.RUnlock()

	return argCopy
}

// MinimockCommitPulseChangeDone returns true if the count of the CommitPulseChange invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockCommitPulseChangeDone() bool {
	for _, e := range m.CommitPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitPulseChange != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitPulseChangeInspect logs each unmet expectation
func (m *DispatcherMock) MinimockCommitPulseChangeInspect() {
	for _, e := range m.CommitPulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.CommitPulseChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitPulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		if m.CommitPulseChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.CommitPulseChange")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.CommitPulseChange with params: %#v", *m.CommitPulseChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitPulseChange != nil && mm_atomic.LoadUint64(&m.afterCommitPulseChangeCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.CommitPulseChange")
	}
}

type mDispatcherMockPreparePulseChange struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockPreparePulseChangeExpectation
	expectations       []*DispatcherMockPreparePulseChangeExpectation

	callArgs []*DispatcherMockPreparePulseChangeParams
	mutex    sync.RWMutex
}

// DispatcherMockPreparePulseChangeExpectation specifies expectation struct of the Dispatcher.PreparePulseChange
type DispatcherMockPreparePulseChangeExpectation struct {
	mock   *DispatcherMock
	params *DispatcherMockPreparePulseChangeParams

	Counter uint64
}

// DispatcherMockPreparePulseChangeParams contains parameters of the Dispatcher.PreparePulseChange
type DispatcherMockPreparePulseChangeParams struct {
	p1 PulseChange
	n1 NodeStateSink
}

// Expect sets up expected params for Dispatcher.PreparePulseChange
func (mmPreparePulseChange *mDispatcherMockPreparePulseChange) Expect(p1 PulseChange, n1 NodeStateSink) *mDispatcherMockPreparePulseChange {
	if mmPreparePulseChange.mock.funcPreparePulseChange != nil {
		mmPreparePulseChange.mock.t.Fatalf("DispatcherMock.PreparePulseChange mock is already set by Set")
	}

	if mmPreparePulseChange.defaultExpectation == nil {
		mmPreparePulseChange.defaultExpectation = &DispatcherMockPreparePulseChangeExpectation{}
	}

	mmPreparePulseChange.defaultExpectation.params = &DispatcherMockPreparePulseChangeParams{p1, n1}
	for _, e := range mmPreparePulseChange.expectations {
		if minimock.Equal(e.params, mmPreparePulseChange.defaultExpectation.params) {
			mmPreparePulseChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPreparePulseChange.defaultExpectation.params)
		}
	}

	return mmPreparePulseChange
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.PreparePulseChange
func (mmPreparePulseChange *mDispatcherMockPreparePulseChange) Inspect(f func(p1 PulseChange, n1 NodeStateSink)) *mDispatcherMockPreparePulseChange {
	if mmPreparePulseChange.mock.inspectFuncPreparePulseChange != nil {
		mmPreparePulseChange.mock.t.Fatalf("Inspect function is already set for DispatcherMock.PreparePulseChange")
	}

	mmPreparePulseChange.mock.inspectFuncPreparePulseChange = f

	return mmPreparePulseChange
}

// Return sets up results that will be returned by Dispatcher.PreparePulseChange
func (mmPreparePulseChange *mDispatcherMockPreparePulseChange) Return() *DispatcherMock {
	if mmPreparePulseChange.mock.funcPreparePulseChange != nil {
		mmPreparePulseChange.mock.t.Fatalf("DispatcherMock.PreparePulseChange mock is already set by Set")
	}

	if mmPreparePulseChange.defaultExpectation == nil {
		mmPreparePulseChange.defaultExpectation = &DispatcherMockPreparePulseChangeExpectation{mock: mmPreparePulseChange.mock}
	}

	return mmPreparePulseChange.mock
}

//Set uses given function f to mock the Dispatcher.PreparePulseChange method
func (mmPreparePulseChange *mDispatcherMockPreparePulseChange) Set(f func(p1 PulseChange, n1 NodeStateSink)) *DispatcherMock {
	if mmPreparePulseChange.defaultExpectation != nil {
		mmPreparePulseChange.mock.t.Fatalf("Default expectation is already set for the Dispatcher.PreparePulseChange method")
	}

	if len(mmPreparePulseChange.expectations) > 0 {
		mmPreparePulseChange.mock.t.Fatalf("Some expectations are already set for the Dispatcher.PreparePulseChange method")
	}

	mmPreparePulseChange.mock.funcPreparePulseChange = f
	return mmPreparePulseChange.mock
}

// PreparePulseChange implements Dispatcher
func (mmPreparePulseChange *DispatcherMock) PreparePulseChange(p1 PulseChange, n1 NodeStateSink) {
	mm_atomic.AddUint64(&mmPreparePulseChange.beforePreparePulseChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmPreparePulseChange.afterPreparePulseChangeCounter, 1)

	if mmPreparePulseChange.inspectFuncPreparePulseChange != nil {
		mmPreparePulseChange.inspectFuncPreparePulseChange(p1, n1)
	}

	mm_params := &DispatcherMockPreparePulseChangeParams{p1, n1}

	// Record call args
	mmPreparePulseChange.PreparePulseChangeMock.mutex.Lock()
	mmPreparePulseChange.PreparePulseChangeMock.callArgs = append(mmPreparePulseChange.PreparePulseChangeMock.callArgs, mm_params)
	mmPreparePulseChange.PreparePulseChangeMock.mutex.Unlock()

	for _, e := range mmPreparePulseChange.PreparePulseChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPreparePulseChange.PreparePulseChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPreparePulseChange.PreparePulseChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmPreparePulseChange.PreparePulseChangeMock.defaultExpectation.params
		mm_got := DispatcherMockPreparePulseChangeParams{p1, n1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPreparePulseChange.t.Errorf("DispatcherMock.PreparePulseChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPreparePulseChange.funcPreparePulseChange != nil {
		mmPreparePulseChange.funcPreparePulseChange(p1, n1)
		return
	}
	mmPreparePulseChange.t.Fatalf("Unexpected call to DispatcherMock.PreparePulseChange. %v %v", p1, n1)

}

// PreparePulseChangeAfterCounter returns a count of finished DispatcherMock.PreparePulseChange invocations
func (mmPreparePulseChange *DispatcherMock) PreparePulseChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPreparePulseChange.afterPreparePulseChangeCounter)
}

// PreparePulseChangeBeforeCounter returns a count of DispatcherMock.PreparePulseChange invocations
func (mmPreparePulseChange *DispatcherMock) PreparePulseChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPreparePulseChange.beforePreparePulseChangeCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.PreparePulseChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPreparePulseChange *mDispatcherMockPreparePulseChange) Calls() []*DispatcherMockPreparePulseChangeParams {
	mmPreparePulseChange.mutex.RLock()

	argCopy := make([]*DispatcherMockPreparePulseChangeParams, len(mmPreparePulseChange.callArgs))
	copy(argCopy, mmPreparePulseChange.callArgs)

	mmPreparePulseChange.mutex.RUnlock()

	return argCopy
}

// MinimockPreparePulseChangeDone returns true if the count of the PreparePulseChange invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockPreparePulseChangeDone() bool {
	for _, e := range m.PreparePulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparePulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparePulseChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPreparePulseChange != nil && mm_atomic.LoadUint64(&m.afterPreparePulseChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockPreparePulseChangeInspect logs each unmet expectation
func (m *DispatcherMock) MinimockPreparePulseChangeInspect() {
	for _, e := range m.PreparePulseChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.PreparePulseChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparePulseChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparePulseChangeCounter) < 1 {
		if m.PreparePulseChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.PreparePulseChange")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.PreparePulseChange with params: %#v", *m.PreparePulseChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPreparePulseChange != nil && mm_atomic.LoadUint64(&m.afterPreparePulseChangeCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.PreparePulseChange")
	}
}

type mDispatcherMockProcess struct {
	mock               *DispatcherMock
	defaultExpectation *DispatcherMockProcessExpectation
	expectations       []*DispatcherMockProcessExpectation

	callArgs []*DispatcherMockProcessParams
	mutex    sync.RWMutex
}

// DispatcherMockProcessExpectation specifies expectation struct of the Dispatcher.Process
type DispatcherMockProcessExpectation struct {
	mock    *DispatcherMock
	params  *DispatcherMockProcessParams
	results *DispatcherMockProcessResults
	Counter uint64
}

// DispatcherMockProcessParams contains parameters of the Dispatcher.Process
type DispatcherMockProcessParams struct {
	msg *Message
}

// DispatcherMockProcessResults contains results of the Dispatcher.Process
type DispatcherMockProcessResults struct {
	err error
}

// Expect sets up expected params for Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Expect(msg *Message) *mDispatcherMockProcess {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	if mmProcess.defaultExpectation == nil {
		mmProcess.defaultExpectation = &DispatcherMockProcessExpectation{}
	}

	mmProcess.defaultExpectation.params = &DispatcherMockProcessParams{msg}
	for _, e := range mmProcess.expectations {
		if minimock.Equal(e.params, mmProcess.defaultExpectation.params) {
			mmProcess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcess.defaultExpectation.params)
		}
	}

	return mmProcess
}

// Inspect accepts an inspector function that has same arguments as the Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Inspect(f func(msg *Message)) *mDispatcherMockProcess {
	if mmProcess.mock.inspectFuncProcess != nil {
		mmProcess.mock.t.Fatalf("Inspect function is already set for DispatcherMock.Process")
	}

	mmProcess.mock.inspectFuncProcess = f

	return mmProcess
}

// Return sets up results that will be returned by Dispatcher.Process
func (mmProcess *mDispatcherMockProcess) Return(err error) *DispatcherMock {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	if mmProcess.defaultExpectation == nil {
		mmProcess.defaultExpectation = &DispatcherMockProcessExpectation{mock: mmProcess.mock}
	}
	mmProcess.defaultExpectation.results = &DispatcherMockProcessResults{err}
	return mmProcess.mock
}

//Set uses given function f to mock the Dispatcher.Process method
func (mmProcess *mDispatcherMockProcess) Set(f func(msg *Message) (err error)) *DispatcherMock {
	if mmProcess.defaultExpectation != nil {
		mmProcess.mock.t.Fatalf("Default expectation is already set for the Dispatcher.Process method")
	}

	if len(mmProcess.expectations) > 0 {
		mmProcess.mock.t.Fatalf("Some expectations are already set for the Dispatcher.Process method")
	}

	mmProcess.mock.funcProcess = f
	return mmProcess.mock
}

// When sets expectation for the Dispatcher.Process which will trigger the result defined by the following
// Then helper
func (mmProcess *mDispatcherMockProcess) When(msg *Message) *DispatcherMockProcessExpectation {
	if mmProcess.mock.funcProcess != nil {
		mmProcess.mock.t.Fatalf("DispatcherMock.Process mock is already set by Set")
	}

	expectation := &DispatcherMockProcessExpectation{
		mock:   mmProcess.mock,
		params: &DispatcherMockProcessParams{msg},
	}
	mmProcess.expectations = append(mmProcess.expectations, expectation)
	return expectation
}

// Then sets up Dispatcher.Process return parameters for the expectation previously defined by the When method
func (e *DispatcherMockProcessExpectation) Then(err error) *DispatcherMock {
	e.results = &DispatcherMockProcessResults{err}
	return e.mock
}

// Process implements Dispatcher
func (mmProcess *DispatcherMock) Process(msg *Message) (err error) {
	mm_atomic.AddUint64(&mmProcess.beforeProcessCounter, 1)
	defer mm_atomic.AddUint64(&mmProcess.afterProcessCounter, 1)

	if mmProcess.inspectFuncProcess != nil {
		mmProcess.inspectFuncProcess(msg)
	}

	mm_params := &DispatcherMockProcessParams{msg}

	// Record call args
	mmProcess.ProcessMock.mutex.Lock()
	mmProcess.ProcessMock.callArgs = append(mmProcess.ProcessMock.callArgs, mm_params)
	mmProcess.ProcessMock.mutex.Unlock()

	for _, e := range mmProcess.ProcessMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcess.ProcessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcess.ProcessMock.defaultExpectation.Counter, 1)
		mm_want := mmProcess.ProcessMock.defaultExpectation.params
		mm_got := DispatcherMockProcessParams{msg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcess.t.Errorf("DispatcherMock.Process got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcess.ProcessMock.defaultExpectation.results
		if mm_results == nil {
			mmProcess.t.Fatal("No results are set for the DispatcherMock.Process")
		}
		return (*mm_results).err
	}
	if mmProcess.funcProcess != nil {
		return mmProcess.funcProcess(msg)
	}
	mmProcess.t.Fatalf("Unexpected call to DispatcherMock.Process. %v", msg)
	return
}

// ProcessAfterCounter returns a count of finished DispatcherMock.Process invocations
func (mmProcess *DispatcherMock) ProcessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcess.afterProcessCounter)
}

// ProcessBeforeCounter returns a count of DispatcherMock.Process invocations
func (mmProcess *DispatcherMock) ProcessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcess.beforeProcessCounter)
}

// Calls returns a list of arguments used in each call to DispatcherMock.Process.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcess *mDispatcherMockProcess) Calls() []*DispatcherMockProcessParams {
	mmProcess.mutex.RLock()

	argCopy := make([]*DispatcherMockProcessParams, len(mmProcess.callArgs))
	copy(argCopy, mmProcess.callArgs)

	mmProcess.mutex.RUnlock()

	return argCopy
}

// MinimockProcessDone returns true if the count of the Process invocations corresponds
// the number of defined expectations
func (m *DispatcherMock) MinimockProcessDone() bool {
	for _, e := range m.ProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcess != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		return false
	}
	return true
}

// MinimockProcessInspect logs each unmet expectation
func (m *DispatcherMock) MinimockProcessInspect() {
	for _, e := range m.ProcessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DispatcherMock.Process with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		if m.ProcessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DispatcherMock.Process")
		} else {
			m.t.Errorf("Expected call to DispatcherMock.Process with params: %#v", *m.ProcessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcess != nil && mm_atomic.LoadUint64(&m.afterProcessCounter) < 1 {
		m.t.Error("Expected call to DispatcherMock.Process")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DispatcherMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelPulseChangeInspect()

		m.MinimockCommitPulseChangeInspect()

		m.MinimockPreparePulseChangeInspect()

		m.MinimockProcessInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DispatcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DispatcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelPulseChangeDone() &&
		m.MinimockCommitPulseChangeDone() &&
		m.MinimockPreparePulseChangeDone() &&
		m.MinimockProcessDone()
}
